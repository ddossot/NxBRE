<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NxBRE</name>
    </assembly>
    <members>
        <member name="T:NxBRE.BREException">
            <summary> The BREException is main exception that can
            be thrown from the Business Rule Engine (BRE)
            </summary>
            <author>  Sloan Seaman
            </author>
            <author>  David Dossot
            </author>
        </member>
        <member name="M:NxBRE.BREException.#ctor">
            <summary> Defines a new BREException
            </summary>
        </member>
        <member name="M:NxBRE.BREException.#ctor(System.String)">
            <summary> Defines a new BREException with a specific msg </summary>
            <param name="aMsg">The error message</param>
        </member>
        <member name="M:NxBRE.BREException.#ctor(System.String,System.Exception)">
            <summary> Defines a new BREException with a specific msg </summary>
            <param name="aMsg">The error message</param>
            <param name="wrappedException">An inner exception wrapped by this one</param>
        </member>
        <member name="T:NxBRE.FlowEngine.BREImpl">
            <summary>The Rule Interpretor implementation of IBRE, the Flow Engine of NxBRE.</summary>
            <remarks>[Author: Sloan Seaman] Take a deep breath.... Inhale... Exhale... Lets begin:
            <P>
            BREImpl is a reference implementation of a Business Rule Engine(BRE).
            </P>
            <P>
            <B>10000' view</B><BR/>
            This accomplishes its task by traversing (DOM) an XML document that should be passed
            in through the init() method.  The XML document MUST adhere to the
            businessRules.xsd Schema.  If it does not you may get some odd behaviors from this
            class. It then call all the executeRule() methods in the defined factories.
            The factories get passed a RuleContext, a Step, and any Parameters that have 
            been set.  The RuleContext contains all
            the generated results so far as well as other BRE related information.  The Step
            is a nullable object that can be used to have one executeRule() execute differently
            depending on the "step" that it is on.  The results of the call to executeRule()
            are wrapped in a BRERuleResult and added to the RuleContext.
            </P>
            <P>
            It is key to note that this class will not throw ANY exceptions unless they are so
            severe that the whole class crashes (99.9% impossible). Instead it listeners.dispatches all
            errors to registered listeners who implement ExceptionListener.  This allows multiple
            object the ability to handle exceptions.
            </P>
            <P>
            Logging occurs via listeners.dispatching to any registered listener who implements
            BRELogListener.  DEBUG as well as WARN, ERROR, and FATAL are created by this class.
            </P>
            <P>
            <B>100' view</B><BR/>
            </P>
            Lets get to the meat of it shall we?
            <P>
            The first method executed should be the init() method.
            The init() method preloads ALL defined Rule factories 
            even if they may never be used. This is to catch any classload 
            exceptions as early on as possible to allows the calling class
            the ability to fix any issues realtime.  If a rule is defined 
            without a factory BREImpl checks to see if it already exists in 
            the RuleContext.  This is because RuleContext may be passed in 
            and may already be populated.  If it does not find a factory anywhere it
            will listeners.dispatch a warning to alert the registered listeners of the issue.
            </P>
            <P>
            The error is only a warning at this point because the process() method
            should not have been called yet thus allowing the calling class the 
            ability to still set things in the RuleContext.
            </P>
            <P>
            The process method should be called next to actually execute the 
            the business rules.  The process method traverses the XML document
            making calls to the defined Factories that implement BRERuleFactory.
            We still have to make sure that the classes implements BRERuleFactory
            because the RuleContext may have changed.  This is a FATAL if this
            occurs.
            </P>
            <P>
            Next it takes the results from the executeRule() and wraps it into a
            RuleResult type.  
            </P>
            <P>
            If an exception occurs within executeRule() BREImpl will listeners.dispatch an ERROR
            to any listening classes and then will take the exception and wrap it with
            BRERuleResult.  This allows the developer the ability to define exception
            cases within the XML document.  In English, you can throw exceptions on 
            purpose and handle them accordingly in the XML doc.
            </P>
            <P>
            The last steps are to add the final RuleResult to the call stack, inform
            any listeners implementing BRERuleResultListener that we have a RuleResult,
            and add the RuleResult to the RuleContext so that other RuleFactories may
            utilize and share the data.
            </P>
            <P>
            <B>Key Notes</B><BR/>
            <OL>
            <LI>This object does not intentionally throw Exceptions.  If a Error listener is
            not registered, you will not know when something blows up!
            </LI>
            <LI>Errors will only be thrown if the object hits a fatal runtime
            error within itself and cannot continue
            </LI>
            </OL>
            </P>
            </remarks>
            <author>  Sloan Seaman </author>
            <author>  David Dossot </author>
        </member>
        <member name="T:NxBRE.FlowEngine.IFlowEngine">
            <summary>
            This interface defines the Flow Engine (FE) of NxBRE.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.IBREDispatcher">
            <summary>
            This interface must be implemented by any class that wants to handle BRE events
            </summary>
            <author>David Dossot</author>
            <remarks>
             The delegate of the same name allows creating custom implementation of the handler.
            </remarks>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Init(System.Xml.XPath.XPathDocument)">
            <summary>
            Initialize the engine with a specific rule base.
            </summary>
            <param name="rulebase"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Init(NxBRE.FlowEngine.IO.IRulesDriver)">
            <summary>
            Initialize the engine by loading rules from a rules driver.
            </summary>
            <param name="rulesDriver"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Process">
            <summary>
            Process the rule base, only executing the rules not defined in any set.
            </summary>
            <returns>
            True if successful, False otherwise
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Process(System.String)">
            <summary>
            Process the rule base, only executing the rules not defined in any set
            <b>and</b> defined in the set whose Id is passed as a parameter.
            </summary>
            <param name="setId">The ID of the set to execute</param>
            <returns> True if successful, False otherwise
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Stop">
            <summary> Violently stop the BRE 
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.IFlowEngine.Reset">
            <summary>Reset the context's call stack and results
            </summary>
        </member>
        <member name="P:NxBRE.FlowEngine.IFlowEngine.RuleContext">
            <summary> Returns or Sets the RuleContext in it's current state.
            If the developer wishes to have a private copy, make sure
            to use Clone().
            This method allows developers to provide an already populated BRERuleContext.
            This is provided to allow for RuleFactories that have already been created, thus 
            allowing a more stateful RuleFactory
            </summary>
            <returns> The RuleContext in its current state</returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IFlowEngine.XmlDocumentRules">
            <summary> Returns the loaded XML Rules in the native NxBRE syntax
            </summary>
            <returns> The loaded XmlDocumentRules</returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IFlowEngine.Running">
            <summary> Running state of the engine, i.e. when processing.
            </summary>
            <returns> True if the engine is processing. </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Clone">
            <summary> Performs a shallow copy of a pre-initialized BRE, i.e. returns a new BRE
            containing a shallow copied rule context, ready to fire!
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Init(System.Xml.XPath.XPathDocument)">
            <summary>
            Initialize the engine with a specific rule base.
            </summary>
            <param name="rulebase"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Init(NxBRE.FlowEngine.IO.IRulesDriver)">
            <summary>
            Initialize the engine by loading rules from a rules driver.
            </summary>
            <param name="rulesDriver"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Reset">
            <summary>Reset the context's call stack and results
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.GetXmlDocumentRules">
            <summary> Returns either an XPathNavigator containing the rules that was passed to Init(),
            or the XmlDocument that the IRuleDriver passed to Init() is set to provide.
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Process">
            <summary> Execute the BRE.
            </summary>
            <returns> True if successful, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Process(System.String)">
            <summary> Execute the BRE but only do a certain set.
            </summary>
            <returns> True if successful, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.Stop">
            <summary> Violently stop the BRE </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.LoadFactories(System.Xml.XPath.XPathNodeIterator)">
            <summary> This method preloads all defined factories with the XML document.
            This is to catch any errors relating to class loading up front before we
            get to the real document parsing and business logic.
            <P>
            This does not support graceful degradation on purpose.
            If I can't get to a business rule, it should be understood
            that technically, in the end, the rules fail.
            </P>
            </summary>
            <param name="aNodeList">The List of Nodes to process
            </param>
            <returns> True if successful, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessXML(System.Xml.XPath.XPathNavigator,System.String,System.Object)">
            <summary> This method processes the XML Document.
            <P>
            This is a recursive alg. So be careful if editing it!!!!!!!
            </P>
            </summary>
            <param name="aNode">The Node to process
            </param>
            <param name="aSetId">The set to process</param>
            <param name="aObj">A bland object for anything
            </param>
            <returns> True if successful, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.DoRecursion(System.Xml.XPath.XPathNavigator,System.String,System.Object)">
            <summary> doRecursive actually does the recursion in terms of callback 
            into the algorythm.  It is in it's own method for code reuse
            reasons.
            <P>
            This may be a bit confusing to some because the recursive alg.
            (processXML) actually calls out to an external method to do the
            calls to go back in. (if that makes sense...)
            </P>
            </summary>
            <param name="aNode">The node to use
            </param>
            <param name="aSetId">The set to process</param>
            <param name="aObj">The generic object to use
            </param>
            <returns>s The object returned by processXML
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessConditionNode(System.Xml.XPath.XPathNavigator,System.String,System.Object)">
            <summary> Processes the Condition Node.
            <P>
            Internally this method is slightly different than the others because it
            handles the children internally.  This is to support the OR/AND 
            functionality that is required.
            </P>
            <P>
            Verbose:</P><P>
            We go through the list of children within a defined BLOCK.
            The BLOCK is defined so we can exit out quickly when we hit our
            criteria. 
            </P>
            <P>
            We only wish to deal with ELEMENT_NODEs. This is key to note because
            children actually contains other types of nodes.
            </P>
            <P>
            If the processState is null (i.e. they did not specifiy AND or OR in
            the XML) we default to AND.
            </P>
            <P>
            If it is not null we check for AND or OR. If AND and the call to
            processXML() (which would end up calling processCompareNode())
            is false, we know the AND fails so we can break out of the loop. 
            Otherwise we just increment our TRUE count.  Incrementing the
            TRUE count isn't really necessary here, but it is for the OR
            condition, and this is a work around.
            </P>
            <P>
            If we get an OR we are only looking for 1 TRUE so we can break
            as soon as we hit it.  We increment the TRUE count here as well.
            This is so that later, if the TRUE count == 0, we know that the
            OR never hit a true statement and should then fail.
            REMEBER: we only break if we hit TRUE, the loop will exit nomally
            if it doesn't.  And since we are optimistic with returnBool being 
            set to TRUE (for the AND stmt) we must set it to false afer the OR
            loop finishes if the trueCount = 0.
            </P>
            </summary>
            <param name="aNode">The Node to process
            </param>
            <param name="aSetId">The set to rule process</param>
            <param name="aObj">The object to evaluate</param>
            <returns> True if the If stmt passes, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.GetOperator(System.String)">
            <summary>Lazy loading of operator.</summary>
             <param name="operatorId">Full qualified name of an operator</param>
             <returns>An operator object implementing IBREOperator</returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessCompareNode(System.Xml.XPath.XPathNavigator,System.Collections.Hashtable)">
            <summary> This methods processes the Compare nodes that may exist in the XML.
            <P>
            The best comparison works when the object implements Comparable.
            </P>
            <P>
            If the object does not do so, it eliminates the &lt;,&gt;,&lt;=,&gt;= 
            functionality as we are left with .equals(), !.equals(), and
            exception
            </P>
            </summary>
            <param name="aNode">The Node to process
            </param>
            <param name="aMap"/>
            <returns> True if the If stmt passes, False otherwise
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessIdValueAttributes(System.Xml.XPath.XPathNavigator,System.String,System.String)">
            <summary> Gets a String Id from either the id attribute or the ruleValue attribute
            </summary>
            <param name="aNode">The node to process</param>
            <param name="idAttribute">The Id of the attribute to process</param>
            <param name="valueAttribute">The value used in this node.</param>
            <returns> The Id found in the node attributes, null if nothing found</returns>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessInvokeSetNode(System.Xml.XPath.XPathNavigator)">
            <summary> Handles the InvokeSet Node
            </summary>
            <param name="aNode">The InvokeSet node to process</param>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessLogNode(System.Xml.XPath.XPathNavigator)">
            <summary> Handles the Log Node
            </summary>
            <param name="aNode">The Node to process
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessParameterNode(System.Xml.XPath.XPathNavigator,System.Collections.Hashtable)">
            <summary> Handles the Parameter node
            </summary>
            <param name="aNode">The Node to process
            </param>
            <param name="aMap">The Parameters map
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.ProcessRuleNode(System.Xml.XPath.XPathNavigator,System.Collections.Hashtable)">
            <summary> Handles the Rule Node and calls doRule()
            </summary>
            <param name="aNode">The Node to process
            </param>
            <param name="aMap">The Parameters map
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.BREImpl.DoRule(System.Object,System.Object,System.Collections.Hashtable)">
            <summary> This methods processes the Rule nodes that may exist in the XML.
            <P>
            It executes as follows (this may not look so straightforward in the code...):
            <OL>
            <LI>Executes Factories executeRule()</LI>
            <LI>takes the result and puts it into a RuleResult object</LI>
            <LI>listeners.dispatches an error if it could not find the factory 
            (See docs in code)</LI>
            <LI>Catches any exceptions from the executeRule() and makes it a 
            RuleResult so it can be handled gracefully</LI>
            <LI>Adds the RuleResult to the CallStack</LI>
            <LI>listeners.dispatched the RuleResult to any listeners</LI>
            <LI>Adds the RuleResult to the RuleContext</LI>
            </OL>
            </P>
            </summary>
            <param name="id">The ID of the Rule
            </param>
            <param name="step">The current Step
            </param>
            <param name="aMap">The Parameters map
            </param>
        </member>
        <member name="P:NxBRE.FlowEngine.BREImpl.RuleContext">
            <summary> Returns or Sets the RuleContext in it's current state.
            <P>
            If the developer wishes to have a private copy, make sure
            to use Clone().
            </P>
            <P>
            This method allows developers to provide an already populated BRERuleContext.
            </P>
            <P>
            This is provides to allow for RuleFactories that have already created, thus 
            allowing a more stateful RuleFactory
            </P>
            </summary>
            <returns> The RuleContext in its current state</returns>
        </member>
        <member name="P:NxBRE.FlowEngine.BREImpl.XmlDocumentRules">
            <summary> Returns the loaded XML Rules in the native NxBRE syntax
            </summary>
            <returns> The loaded Business Rules</returns>
        </member>
        <member name="P:NxBRE.FlowEngine.BREImpl.Running">
            <summary> Running state of the engine, i.e. when processing.
            </summary>
            <returns> True if the engine is processing. </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.BRERuleException">
            <summary> This error is thrown when an error is generated from
            the Busines Rule (BRF), usually from the executeRule().
            Not really used much....
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleException.#ctor">
            <summary>
            Defines a new BRERuleFatalException with a specific msg
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleException.#ctor(System.String)">
            <summary> Defines a new BRERuleFatalException with a specific msg
            </summary>
            <param name="aMsg">The error message
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleException.#ctor(System.String,NxBRE.FlowEngine.IBRERuleResult)">
            <summary> Defines a new BRERuleException with a specific msg,
            and the resultSet that may have been created (nullable)
            </summary>
            <param name="aMsg">The error message
            </param>
            <param name="aBRR">The BusinessRuleResult that may have been created
            </param>
        </member>
        <member name="P:NxBRE.FlowEngine.BRERuleException.RuleResult">
            <summary> Returns a RuleResult that may have been created when the
            exception occurred.  This object can be null.
            </summary>
            <returns> The RuleResult
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.BRERuleFactory">
            <summary>An helper class that allows connecting business rules and custom functions
            called by delegates.<br/>
            It supports two constructors, one expecting a delegate,
            the other one able to build the delegate on-the-fly (this probably carries a performance
            issue due to reflection) and prevents compile time type-checking.
            </summary>
            <author>  David Dossot
            </author>
        </member>
        <member name="T:NxBRE.FlowEngine.IBRERuleFactory">
            <summary> The BRERuleFactory defines the default interface to use with the 
            Business Rule Engine (BRE).  
            A class implementing BRERuleFactory is callable by the BRE to execute 
            specific business rule code based on the information provided by the
            BRERuleContext object.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleFactory.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> The executeRule() method is invoked by the Business Rule Engine (BRE)
            to execute the specific rule for this class.
            *
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aStep">The specific rule to execute.  This allows the same class
            and method to be used for multiple Business Rules.
            </param>
            <param name="aMap">An IDictionary object containing the parameters from the XML
            </param>
            <returns> The object containing the results of the
            rule.
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.BRERuleFatalException">
            <summary> This error is thrown when a severe error is generated from
            the Busines Rule (BRF), usually from the executeRule().
            If this error occurs within executeRule, any errors in a stack should
            be immediatly processed and an attempt to gracefully degradate the application
            should occur.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleFatalException.#ctor">
            <summary>
            Defines a new BRERuleFatalException with a specific msg
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleFatalException.#ctor(System.String)">
            <summary> Defines a new BRERuleFatalException with a specific msg
            </summary>
            <param name="aMsg">The error message
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.BRERuleFatalException.#ctor(System.String,NxBRE.FlowEngine.IBRERuleResult)">
            <summary> Defines a new BRERuleFatalException with a specific msg,
            and the resultSet that may have been created (nullable)
            </summary>
            <param name="aMsg">The error message
            </param>
            <param name="aBRR">The BusinessRuleResult that may have been created
            
            </param>
        </member>
        <member name="T:NxBRE.FlowEngine.IBREOperator">
            <summary> This interface defines the comparison methods used by operators from
            within the Compare tag
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.IBREOperator.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Method to compare one object against another
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">An IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>s True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBREOperator.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>True or False depending of the operator.</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.IBRERuleContext">
            <summary> This interface defines an object that will be passed between
            the various objects that implement BRERuleFactory (BRF).  
            The intent of this object is to provide a free-form manner of
            passing information between the various BRF's to allow them
            access to specific information they may require for their business
            decisions.
            </summary>
            <author>  Sloan Seaman </author>
            <author>  David Dossot </author>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.GetFactory(System.Object)">
            <summary> Returns a BRERuleFactory specified by the specific UID
            *
            </summary>
            <param name="aId">The UID of the RuleFactory
            </param>
            <returns> The requested RuleFactory
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.GetOperator(System.Object)">
            <summary> Returns the requested Operator
            *
            </summary>
            <returns> The requested Operator
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.GetResult(System.Object)">
            <summary> Returns a BusinessRuleResult that was generated from a BRF
            *
            </summary>
            <param name="aId">The UID of the ResultSet
            </param>
            <returns> The requested RuleResult
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.SetFactory(System.Object,NxBRE.FlowEngine.IBRERuleFactory)">
            <summary> Sets a RuleFactory
            *
            </summary>
            <param name="aId">The UID of the RuleFactory
            </param>
            <param name="aFactory">The Factory
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.SetOperator(System.Object,NxBRE.FlowEngine.IBREOperator)">
            <summary> Sets an Operator
            *
            </summary>
            <param name="aId">The UID of the Operator
            </param>
            <param name="aOperator">The operator
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.SetResult(System.Object,NxBRE.FlowEngine.IBRERuleResult)">
            <summary> Sets a RuleResult
            *
            </summary>
            <param name="aId">The UID of the RuleResult
            </param>
            <param name="aResult">The RuleResult
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.SetObject(System.Object,System.Object)">
            <summary> Sets a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <param name="aObject">The business object</param>
        </member>
        <member name="M:NxBRE.FlowEngine.IBRERuleContext.GetObject(System.Object)">
            <summary> Returns a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <returns> The requested business object
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleContext.CallStack">
            <summary> Returns an Stack of BRERuleFactory UID's that represents
            the call stack up to the point of this method invocation
            *
            </summary>
            <returns> An Stack of BRERuleFactory UID's
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleContext.FactoryMap">
            <summary> Returns an IDictionary of the RuleFactories
            *
            </summary>
            <returns> IDictionary of RuleFactories
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleContext.OperatorMap">
            <summary> Returns an IDictionary of the Operator
            *
            </summary>
            <returns> IDictionary of the Operators
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleContext.ResultsMap">
            <summary> Returns an IDictionary of the Results
            *
            </summary>
            <returns> IDictionary of Results Map
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.IBRERuleMetaData">
            <summary> This interface defines information about a specific Business Rule. 
            *
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleMetaData.Factory">
            <summary> Returns the BRERuleFactory that created the Business Rule
            *
            </summary>
            <returns>s The parent BRERuleFactory
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleMetaData.Id">
            <summary> Returns a UID for this result set
            *
            </summary>
            <returns> The UID of this result
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleMetaData.Parameters">
            <summary> Returns any parameters that were passed in to the specific instance of this
            Rule
            *
            </summary>
            <returns> An IDictionary of the parameters
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleMetaData.StackLocation">
            <summary> Returns the location that the RuleResult was returned from in 
            the call stack
            *
            </summary>
            <returns> The location of the RuleResult on the stack
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleMetaData.Step">
            <summary> Returns the step that was called in the executeRule() within
            the parent BRERuleFactory.
            Note: Can be NULL!
            *
            </summary>
            <returns>The step that was called.
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.IBRERuleResult">
            <summary> This object defines the interface for all objects that wish to contain
            a result created by a BusinessRuleFactory.
            *
            The result can be of any type.  The BRERuleMetaData object contains 
            information specific to this result.
            *
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleResult.MetaData">
            <summary> Returns the MetaData specific to this BusinessRuleResult
            *
            </summary>
            <returns> The relative metadata
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.IBRERuleResult.Result">
            <summary> Returns the result of the Business Rule
            *
            </summary>
            <returns> The object resulting from the execution of the Business Rule
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.BRERuleResultImpl">
            <summary> Strict implementation of BRERuleRuleResult
            *
            This class is sealed so that no one tries to extend it. 
            Implementation Inheritance can be a dangerous thing.
            <P>
            If a developer wishes to extend this in some way they should use
            AbstractBRERuleContext instead since it is designed to be added on to.
            </P>
            *
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.Core.AbstractBRERuleResult">
            </seealso>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.AbstractBRERuleResult">
            <summary> Abstract definition of BRERuleResult.
            Use this if you wish to do inheritance.
            *
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.IBRERuleResult"/>
            <author>Sloan Seaman</author>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleResult.#ctor(NxBRE.FlowEngine.IBRERuleMetaData,System.Object)">
            <summary> Protected constructor to allow for data structure population
            *
            </summary>
            <param name="aMetaData">The RuleMetaData of the RuleResult
            </param>
            <param name="aResult">The actual result
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleResult.ToString">
            <summary> Display Method </summary>
            <returns> String containing info</returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleResult.MetaData">
            <summary> Returns the MetaData specific to this BusinessRuleResult
            *
            </summary>
            <returns> The relative metadata
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleResult.Result">
            <summary> Returns the result of the Business Rule
            *
            </summary>
            <returns> The object resulting from the execution of the Business Rule
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleResultImpl.#ctor(NxBRE.FlowEngine.IBRERuleMetaData,System.Object)">
            <summary> Creates a new instance of the object
            <P> 
            This constructor makes a call to a protected constructor
            within AbstractBRERuleContext.  This is another reason
            why this class in final, because this technically breaks
            encapsulation.  For more info see:</P><P>
            <I>Effective Java</I> (first printing) by Joshua Bloch.</P>
            Item 14, pg. 71
            *
            </summary>
            <param name="aMetaData">The RuleMetaData of the RuleResult
            </param>
            <param name="aResult">The actual result
            
            </param>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.AbstractBRERuleContext">
            <summary> Abstract definition of BRERuleContext.
            There is a good chance that RuleContexts may change per
            client, so an abstract object is provided to assist this.
            Use this if you wish to do inheritance.
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.Core.BRERuleContextImpl"/>
            <author>  Sloan Seaman </author>
            <author>  David Dossot </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.#ctor(System.Collections.Stack,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary)">
            <summary> Protected constructor to allow for data structure population
            *
            </summary>
            <param name="aStack">The Stack for the call stack
            </param>
            <param name="aResults">The IDictionary for the RuleResults
            </param>
            <param name="aFactories">The IDictionary for the RuleFactory's
            </param>
            <param name="aOperators">The IDictionary for the Operators
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.Clone">
            <summary> Performs a shallow copy of the Rule Context, i.e. returns a new RuleContext
            containing shallow copies of its internal hashtables and stack
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.GetFactory(System.Object)">
            <summary> Returns a BRERuleFactory specified by the specific UID
            *
            </summary>
            <param name="aId">The UID of the RuleFactory
            </param>
            <returns> The requested RuleFactory
            @throws ClassCastException If object retrieved is not of type BRERuleFactory
            (This is only possible if the developer passes in a Map object that
            is already populated with other objects)
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.GetOperator(System.Object)">
            <summary> Returns a parameter that was set for use by the RuleFactory
            *
            </summary>
            <param name="aId">The UID of the parameter
            </param>
            <returns> The corresponding value
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.GetResult(System.Object)">
            <summary> Returns a BusinessRuleResult that was generated from a BRF
            *
            </summary>
            <param name="aId">The UID of the ResultSet
            </param>
            <returns> The requested RuleResult
            @throws ClassCastException If object retrieved is not of type BRERuleResult
            (This is only possible if the developer passes in a Map object that
            is already populated with other objects)
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.SetFactory(System.Object,NxBRE.FlowEngine.IBRERuleFactory)">
            <summary> Sets a RuleFactory
            *
            </summary>
            <param name="aId">The UID of the RuleFactory
            </param>
            <param name="aFactory">The Factory
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.SetOperator(System.Object,NxBRE.FlowEngine.IBREOperator)">
            <summary> Sets a parameter for use by RuleFactories
            *
            </summary>
            <param name="aId">The UID of the parameter
            </param>
            <param name="aValue">The value to set
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.SetResult(System.Object,NxBRE.FlowEngine.IBRERuleResult)">
            <summary> Sets a RuleResult
            *
            </summary>
            <param name="aId">The UID of the RuleResult
            </param>
            <param name="aResult">The RuleResult
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.SetObject(System.Object,System.Object)">
            <summary> Sets a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <param name="aObject">The business object
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.GetObject(System.Object)">
            <summary> Returns a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <returns> The requested business object
            
            </returns>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleContext.ToString">
            <summary> Display Method
            *
            </summary>
            <returns> String containing info
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleContext.CallStack">
            <summary> Returns a Stack of BRERuleFactory UID's that represents
            the call stack up to the point of this method invocation
            *
            </summary>
            <returns> An Stack of BRERuleFactory UID's
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleContext.FactoryMap">
            <summary> Returns a Map of the RuleFactories
            *
            </summary>
            <returns> Map of RuleFactories
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleContext.OperatorMap">
            <summary> Returns the internal parameters map
            *
            </summary>
            <returns> The Map object containing all parameters
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleContext.ResultsMap">
            <summary> Returns a Map of the Results
            *
            </summary>
            <returns> Map of Results Map
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData">
            <summary> Abstract implementation of BRERuleMetaData.
            Use this if you wish to do inheritance.
            *
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.IBRERuleMetaData"/>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.#ctor(System.Object,NxBRE.FlowEngine.IBRERuleFactory,System.Collections.IDictionary,System.Int32,System.Object)">
            <summary> Protected constructor to allow for data structure population
            *
            </summary>
            <param name="aId">The UID of the RuleResult
            </param>
            <param name="aFactory">The RuleFactory that create the RuleResult
            </param>
            <param name="aParams">An IDictionary of the parameters
            </param>
            <param name="aStackLoc">The location on the stack of this RuleResult
            </param>
            <param name="aStep">The step within the rule
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.ToString">
            <summary> Display Method
            *
            </summary>
            <returns> String containing info
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.Factory">
            <summary> Returns the BRERuleFactory that created the Business Rule
            *
            </summary>
            <returns>s The parent BRERuleFactory
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.Id">
            <summary> Returns a UID for this result set
            *
            </summary>
            <returns> The UID of this result
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.Parameters">
            <summary> Returns any parameters that were passed in to the specific instance of this
            Rule
            *
            </summary>
            <returns> An IDictionary of the parameters
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.StackLocation">
            <summary> Returns the location that the RuleResult was returned from in 
            the call stack
            *
            </summary>
            <returns> The location of the RuleResult on the stack
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData.Step">
            <summary> Returns the step that was called in the executeRule() within
            the parent BRERuleFactory.
            Note: Can be NULL!
            *
            </summary>
            <returns>The step that was called.
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.BRERuleContextImpl">
            <summary> Strict implementation of BRERuleContext.
            <P>
            This class is sealed so that no one tries to extend it. 
            Implementation Inheritance can be a dangerous thing.
            </P>
            <P>
            If a developer wishes to extend this in some way they should use
            AbstractBRERuleContext instead since it is designed to be added on to.
            </P>
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.Core.AbstractBRERuleContext">
            </seealso>
            <author>  Sloan Seaman </author>
            <author>  David Dossot </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleContextImpl.#ctor(System.Collections.Stack,System.Collections.Hashtable,System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary> Creates a new instance of the object
            <P> 
            This constructor makes a call to a protected constructor
            within AbstractBRERuleContext.  This is another reason
            why this class is sealed, because this technically breaks
            encapsulation.  For more info see:</P><P>
            <I>Effective Java</I> (first printing) by Joshua Bloch.
            Item 14, pg. 71
            </P>
            *
            </summary>
            <param name="aStack">The Stack for the call stack
            </param>
            <param name="aFactories">The Map for the RuleFactory's
            </param>
            <param name="aOperators">The Map for the Operators
            </param>
            <param name="aResults">The Map for the RuleResults
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleContextImpl.Clone">
            <summary> Performs a shallow copy of the Rule Context, i.e. returns a new RuleContext
            containing shallow copies of its internal hashtables and stack
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleContextImpl.SetObject(System.Object,System.Object)">
            <summary> Sets a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <param name="aObject">The business object
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleContextImpl.GetObject(System.Object)">
            <summary> Returns a business object
            *
            </summary>
            <param name="aId">The UID of the business object
            </param>
            <returns> The requested business object</returns>
            <remarks>Never use this method in the engine itself: the engine should only rely on GetResult.</remarks>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.BRERuleMetaDataImpl">
            <summary> Strict implementation of BRERuleMetaData
            <P>
            This class is sealed so that no one tries to extend it. 
            Implementation Inheritance can be a dangerous thing.
            </P>
            <P>
            If a developer wishes to extend this in some way they should use
            AbstractBRERuleContext instead since it is designed to be added on to.
            </P>
            *
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.Core.AbstractBRERuleMetaData">
            </seealso>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleMetaDataImpl.#ctor(System.Object,NxBRE.FlowEngine.IBRERuleFactory,System.Collections.Hashtable,System.Int32,System.Object)">
            <summary> Creates a new instance of the object
            <P> 
            This constructor makes a call to a protected constructor
            within AbstractBRERuleContext.  This is another reason
            why this class in final, because this technically breaks
            encapsulation.  For more info see:</P><P>
            <I>Effective Java</I> (first printing) by Joshua Bloch. 
            Item 14, pg. 71
            </P>
            *
            </summary>
            <param name="aId">The UID of the RuleResult
            </param>
            <param name="aFactory">The RuleFactory that create the RuleResult
            </param>
            <param name="aParams">A Map of the parameters
            </param>
            <param name="aStackLoc">The location on the stack of this RuleResult
            </param>
            <param name="aStep">The step within the rule
            
            </param>
        </member>
        <member name="T:NxBRE.FlowEngine.Core.BRERuleObject">
            <summary>An helper class that allows adding business objects in the result context
            </summary>
            <seealso cref="T:NxBRE.FlowEngine.Core.AbstractBRERuleResult">
            </seealso>
            <author>  David Dossot
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Core.BRERuleObject.#ctor(System.Object)">
            <summary> Creates a new instance of the object
            <P> 
            This constructor makes a call to a protected constructor
            within AbstractBRERuleContext.  This is another reason
            why this class in final, because this technically breaks
            encapsulation.  For more info see:</P><P>
            <I>Effective Java</I> (first printing) by Joshua Bloch.</P>
            Item 14, pg. 71
            *
            </summary>
            <param name="aObject">The object to add to the result context
            </param>
        </member>
        <member name="T:NxBRE.FlowEngine.Factories.BREFactory">
            <summary>This factory allows an easy creation of a BRE object</summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.Factories.BREFactoryConsole">
            <summary>This factory allows an easy creation of a BRE object,
            that redirects its log and error messages on Console Out and Error</summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.Factories.BRECloneFactory">
            <summary>This factory allows an easy creation of a BRE objects from a unique Clone,<br/>
            which is very convenient for a multi-threaded environment where each thread will
            use a different clone.</summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.XBusinessRulesStreamDriver">
            <summary>
            Driver for loading rules streams valid against xBusinessRules.xsd (simplified NxBRE grammar).
            The native NxBRE rules file will be generated by XSLT.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.AbstractRulesDriver">
            <summary>
            Driver for loading NxBRE rules from different sources.
            <see cref="T:NxBRE.FlowEngine.IO.IRulesDriver"/>
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.IRulesDriver">
            <summary>
            Interface that any rules driver must implement.
            A rule driver is responsible for fetching rules data from a certain source
            and returning an XmlReader on it.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.FlowEngine.IO.IRulesDriver.GetXmlReader">
            <summary>Member to retrieve a XmlReader</summary>
        </member>
        <member name="M:NxBRE.FlowEngine.IO.AbstractRulesDriver.GetReader">
            <summary>Builder pattern where the actual implementation is delegated to a descendant concrete class</summary>
        </member>
        <member name="M:NxBRE.FlowEngine.IO.AbstractRulesDriver.#ctor(System.String)">
            <summary>The XML rule source (either an URI or a string containing an XML fragment)</summary>
             <param name="xmlSource">The URI of the rule file</param>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.XBusinessRulesStringDriver">
            <summary>
            Driver for loading rules strings valid against xBusinessRules.xsd (simplified NxBRE grammar).
            The native NxBRE rules file will be generated by XSLT.
            </summary>
            <author>David Dossot</author>
            <remarks>
             xBusinessRules.xsd, transformXRules.xsl and businessRules.xsd must be included in the assembly.
             Thanks to Mohsin Ali Sheikh for having decided me to write it!
            </remarks>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.XSLTRulesFileDriver">
            <summary>
            Driver for loading rules, which first executes an XSLT.
            The resulting XML document must be valid against businessRules.xsd
            </summary>
            <author>David Dossot</author>
            <remarks>
             businessRules.xsd must be included in the assembly.
            </remarks>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.BusinessRulesFileDriver">
            <summary>
            Driver for loading rules files valid against businessRules.xsd (native NxBRE grammar)
            </summary>
            <author>David Dossot</author>
            <remarks>
             businessRules.xsd must be included in the assembly.
            </remarks>
        </member>
        <member name="T:NxBRE.FlowEngine.IO.XBusinessRulesFileDriver">
            <summary>
            Driver for loading rules files valid against xBusinessRules.xsd (simplified NxBRE grammar).
            The native NxBRE rules file will be generated by XSLT.
            </summary>
            <author>David Dossot</author>
            <remarks>
             xBusinessRules.xsd, transformXRules.xsl and businessRules.xsd must be included in the assembly.
            </remarks>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.GreaterThan">
            <summary> Compares two objects to see if one is greater than the other
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.IInitializable">
            <summary> Define a generic interface that allows developers to ensure
            that an Flow Engine Rules, upon newInstance() or creation, has a callable
            method to initialize the object.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.IInitializable.Init(System.Object)">
            <summary> Initialized the object
            *
            </summary>
            <param name="aObj">An object that is passed upon initialization
            </param>
            <returns> True is successful, False otherwise
            @throws Exception if there is an initialization error
            
            </returns>
        </member>
        <member name="F:NxBRE.FlowEngine.Rules.GreaterThan.optimistic">
            <summary> Vairable that holds the optimism
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.GreaterThan.Init(System.Object)">
            <summary> Takes a Boolean as its object.  The Boolean represents
            if the object should be pessistic or optimistic when 
            doing a comparison. I.E. if it cannot do a comparison
            does it return true or false.  Default is false..
            *
            </summary>
            <param name="aObj">A Boolean containing the optimism
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.GreaterThan.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Checks the two objects to see if one is greater than the other
            <P>
            If the objects are not <code>Comparable</code> then we default
            to the optimism that is set.  The default is false.
            *
            </P>
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">An IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns> True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.GreaterThan.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.GreaterThanEqualTo">
            <summary> Compares two objects to see if they are greater than or equal to each other.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="F:NxBRE.FlowEngine.Rules.GreaterThanEqualTo.optimistic">
            <summary> Vairable that holds the optimism
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.GreaterThanEqualTo.Init(System.Object)">
            <summary> Takes a Boolean as its object.  The Boolean represents
            if the object should be pessistic or optimistic when 
            doing a comparison. I.E. if it cannot do a comparison
            does it return true or false.  Default is false..
            *
            </summary>
            <param name="aObj">A Boolean containing the optimism
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.GreaterThanEqualTo.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Compares two objects to see if they are greater than or equal to each other
            <P>
            If the objects are not <code>Comparable</code> then we default
            to the optimism that is set.  The default is false.
            *
            </P>
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">An IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>s True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.GreaterThanEqualTo.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Increment">
            <summary> This class is designed to be used to increment everytime the executeRule is called.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Increment.Init(System.Object)">
            <summary> Takes an Integer with a value equal to the starting index point
            </summary>
            <param name="aObj">An Integer representing the starting index point
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Increment.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> If passed the parameter Increment it will increment the index.
            Otherwise it will just return the current value of the index
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> The current value of the increment
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.IncrementInit">
             <summary> This class is designed to reset increments or decrements
             <P>
             This class takes the following parameters:</P>
             <P>
             Examples:</P>
             <PRE>
             <Rule id="VALUE1" factory="NxBRE.FlowEngine.rule.helpers.IncrementInit">
             <Parameter name="Id" value="INC_X"/>
             <Parameter name="Init" value="25"/>
             </Rule>
            
             <Rule id="VALUE1" factory="NxBRE.FlowEngine.rule.helpers.IncrementInit">
             <Parameter name="Id" value="INC_X"/>
             <Parameter name="Init" ruleValue="abc"/>
             </Rule>
             </PRE>
             </summary>
             <author>  David Dossot
             </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.IncrementInit.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> If passed the parameter Id and Init it call the Init method of
            the Increment
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> The current value of the index
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.InstanceOf">
            <summary> Checks if one object is the instance of another
            </summary>
            <author>  Sloan Seaman </author>
            <author>  David Dossot </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.InstanceOf.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Checks if one object is the instance of another
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">An IDictionary Map object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.InstanceOf.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>True for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.LessThan">
            <summary> Compares two objects to see if one is less than the other
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="F:NxBRE.FlowEngine.Rules.LessThan.optimistic">
            <summary> Vairable that holds the optimism
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.LessThan.Init(System.Object)">
            <summary> Takes a Boolean as its object.  The Boolean represents
            if the object should be pessistic or optimistic when 
            doing a comparison. I.E. if it cannot do a comparison
            does it return true or false.  Default is false..
            *
            </summary>
            <param name="aObj">A Boolean containing the optimism
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.LessThan.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Checks the two objects to see if one is less than the other
            <P>
            If the objects are not <code>Comparable</code> then we default
            to the optimism that is set.  The default is false.
            *
            </P>
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">A IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>s True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.LessThan.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.LessThanEqualTo">
            <summary> Compares two objects to see if they are less than or equal to each other.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="F:NxBRE.FlowEngine.Rules.LessThanEqualTo.optimistic">
            <summary> Vairable that holds the optimism
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.LessThanEqualTo.Init(System.Object)">
            <summary> Takes a Boolean as its object.  The Boolean represents
            if the object should be pessistic or optimistic when 
            doing a comparison. I.E. if it cannot do a comparison
            does it return true or false.  Default is false.
            *
            </summary>
            <param name="aObj">A Boolean containing the optimism
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.LessThanEqualTo.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Compares two objects to see if they are less than or equal to each other
            <P>
            If the objects are not <code>Comparable</code> then we default
            to the optimism that is set.  The default is false.
            *
            </P>
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">An IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>s True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.LessThanEqualTo.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.NotEquals">
            <summary> Compares two objects to see if they are not equal.
            *
            </summary>
            <P>
            <PRE>
            CHANGELOG:
            v1.5	- Created
            </PRE>
            </P>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.NotEquals.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Checks the two objects to see if they are not equal
            *
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">Not used yet. A IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns>s True if they meet the condition, False otherwise.
            
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.NotEquals.AcceptsNulls">
            <summary>Defines whether an operator is ablt to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.ObjectLookup">
            <summary> This class is designed to be used anytime you wish to access
            a member of an object stored in the Rule Context and referenced by an Id
            or a static method on a class.
            <P>
            This class takes the following parameters:</P><P>
            Member - The member to access: field, property or method name.</P><P>
            ArgumentX - The argument(s) to be passed to the constructor</P><P>
            ObjectId - The Id of the object to access in the result context</P><P>
            - or -</P><P>
            Class - The full class name, optionally suffixed with the assembly name</P>
            <P>
            Example:
            <PRE>
            <Rule id="VALUE1" factory="NxBRE.FlowEngine.rule.helpers.ObjectLookup">
            <Parameter name="ObjectId" value="myObject"/>
            <Parameter name="Member" value="myMethod"/>
            </Rule>
            <Rule id="VALUE2" factory="NxBRE.FlowEngine.rule.helpers.ObjectLookup">
            <Parameter name="Type" value="test.MyClass,MyAssembly"/>
            <Parameter name="Member" value="myStaticMethod"/>
            <Parameter name="Argument0" value="a_string"/>
            <Parameter name="Argument1" ruleValue="an_object"/>
            <Parameter name="Argument2" value="5.25" type="System.Double"/>
            </Rule>
            </PRE>
            *
            </P>
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.ObjectLookup.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Returns a value cast to a specific type
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> The value cast to the specified type
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.True">
            <summary> This rule will always return true.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.True.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Always returns true
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> Boolean.TRUE
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Value">
            <summary> This class is designed to be used anytime you wish to set
            a value in the XML itself. 
            <P>
            The value can be of any type and of any value.
            </P>
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Value.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Returns a value cast to a specific type
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> The value cast to the specified type
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Decrement">
            <summary> This class is designed to be used to decrement everytime the executeRule is called
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Decrement.Init(System.Object)">
            <summary> Takes an Integer with a value equal to the starting index point
            *
            </summary>
            <param name="aObj">An Integer representing the starting index point
            
            </param>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Decrement.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> If passed the parameter Decrement it will decrement the index.
            Otherwise it will just return the current value of the index
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> The current value of the index
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Equals">
            <summary> Compares two objects to see if they are equal.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Equals.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Checks the two objects to see if they are equal
            *
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">Not used yet. An IDictionary object containing the parameters from the XML
            </param>
            <param name="aObj">The object (value) to compare against.
            </param>
            <param name="aCompareTo">The object to compare it to.
            </param>
            <returns> True if they meet the condition, False otherwise.
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.Equals.AcceptsNulls">
            <summary>Defines whether an operator is able to deal with empty operands</summary>
            <returns>False for the current operator</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Exception">
            <summary> This rule will always throw an exception.
            </summary>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Exception.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Throws a BRERuleException with the message "Test Exception"
            unless the parameter Message provides a specific message.
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns>The Exception</returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.False">
            <summary> This rule will always return false.
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.False.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Always returns false
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns> Boolean.FALSE
            
            </returns>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.FatalException">
            <summary> This rule will always throw a fatal exception
            </summary>
            <author>  Sloan Seaman
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.FatalException.ExecuteRule(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object)">
            <summary> Throws a BRERuleFatalException with the message "Test Fatal Exception"
            *
            </summary>
            <param name="aBrc">- The BRERuleContext object
            </param>
            <param name="aMap">- The IDictionary of parameters from the XML
            </param>
            <param name="aStep">- The step that it is on
            </param>
            <returns>The exception</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.EventContextFactory">
            <summary>
            A factory for building event contexts.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IEventContext">
            <summary>
            Defines the information available in the event context.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEventContext.Facts">
            <summary>
            The facts that are source of this event.
            </summary>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the source facts.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEventContext.Implication">
            <summary>
            The implication source of this event.
            </summary>
            <returns>The source implication.</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.WorkingMemoryTypes">
            <summary>
            The available types of working memory.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.WorkingMemoryTypes.Global">
            <summary>
            The global working memory that contains common facts.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.WorkingMemoryTypes.Isolated">
            <summary>
            An isolated working memory that contains a copy of the global facts plus facts locally asserted or deducted.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.WorkingMemoryTypes.IsolatedEmpty">
            <summary>
            An isolated working memory that contains only facts locally asserted or deducted.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.ThreadingModelTypes">
            <summary>
            The available types of working memory threading model.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.ThreadingModelTypes.Single">
            <summary>
            Threading model that is suitable for <b>single threaded applications only</b>.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.ThreadingModelTypes.Multi">
            <summary>
            Threading model that is suitable for multi-threaded applications, but does not support rulebase reloading.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.ThreadingModelTypes.MultiHotSwap">
            <summary>
            Threading model that is suitable for multi-threaded applications and supports rulebase reloading (hot-swapping).
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.FactBaseStorageTypes">
            <summary>
            The available types for fact base storage.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.FactBaseStorageTypes.Hashtable">
            <summary>
            Hashtable is the faster and have been proven collision-safe to 300,000 facts.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.FactBaseStorageTypes.DataTable">
            <summary>
            DataTable is the slowest but is fully collision-safe.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IEImpl">
            <summary>
            The Inference Engine of NxBRE.
            </summary>
            <remarks>
            Except for asserting/retracting facts and running queries, this implementation does
            not offer an API for the Rule Base. The rule base source is the Adapter, this is where
            customization should take place for feeding the engine with rules from other sources than
            RuleML files.
            </remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.IInferenceEngine">
            <summary>
            This interface defines the Inference Engine (IE) of NxBRE.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter)">
            <summary>
            Loads a rule base and process the performatives. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            This is equivalent to calling: <code>LoadRuleBase(adapter, true)</code>
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,NxBRE.InferenceEngine.IO.IBinder)">
            <summary>
            Loads a rule base and process the performatives. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            This is equivalent to calling: <code>LoadRuleBase(adapter, businessObjectsBinder, true)</code>
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,System.Boolean)">
            <summary>
            Loads a rule base. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="processPerformatives">Immediatly process the performative actions (assert, retract) found in the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,NxBRE.InferenceEngine.IO.IBinder,System.Boolean)">
            <summary>
            Loads a rule base. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
            <param name="processPerformatives">Immediatly process the performative actions (assert, retract) found in the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.SaveRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter)">
            <summary>
            Saves the WorkingMemory in a rule base.
            </summary>
            <param name="adapter">The Adapter used to save the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.LoadFacts(NxBRE.InferenceEngine.IO.IFactBaseAdapter)">
            <summary>
            Load facts in the current working memory. Current implications, facts and queries
            remain unchanged.
            </summary>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <param name="adapter">The Adapter used to read the fact base.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.SaveFacts(NxBRE.InferenceEngine.IO.IFactBaseAdapter)">
            <summary>
            Save facts of the current working memory. Current implications, facts and queries
            remain unchanged.
            </summary>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <param name="adapter">The Adapter used to save the fact base.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.NewWorkingMemory(NxBRE.InferenceEngine.WorkingMemoryTypes)">
            <summary>
            Sets the WorkingMemory of the engine, either by forking the existing Global memory
            to a new Isolated one, or by simply using the Global one.
            </summary>
            <param name="memoryType">The new type of working memory.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.CommitIsolatedMemory">
            <summary>
            Makes the current isolated memory the new global memory and sets the working memory
            type to global. Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.DisposeIsolatedMemory">
            <summary>
            Dispose the current isolated memory sets the working memory type to global.
            Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Process">
            <summary>
            Process all the performative and connective rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            This is equivalent to calling: <code>Process(ProcessModes.ConnectivesOnly)</code>
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Process(NxBRE.InferenceEngine.RuleTypes)">
            <summary>
            Process the selected rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <param name="ruleType">The particular rule type to process.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Process(System.Collections.IDictionary)">
            <summary>
            Process all the performative and connective rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            This is equivalent to calling: <code>Process(businessObjects, ProcessModes.ConnectivesOnly)</code>
            If businessObjects is Null, this method performs the same operation as <code>Process()</code>
             ; else it uses the binder provided in the constructor to perform fact operations and
            orchestrate the process.
            If businessObjects is not Null and no binder has been provided in the constructor, it throws
            a BREException.
            </remarks>
            <param name="businessObjects">An IDictionary of business objects, or Null.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Process(System.Collections.IDictionary,NxBRE.InferenceEngine.RuleTypes)">
            <summary>
            Process the selected rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            If businessObjects is Null, this method performs the same operation as <code>Process()</code>
             ; else it uses the binder provided in the constructor to perform fact operations and
            orchestrate the process.
            If businessObjects is not Null and no binder has been provided in the constructor, it throws
            a BREException.
            </remarks>
            <param name="businessObjects">An IDictionary of business objects, or Null.</param>
            <param name="ruleType">The particular rule type to process.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.FactExists(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="fact">The Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.FactExists(System.String)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.GetFact(System.String)">
            <summary>
            Returns a Fact from its label if it exists, else returns null.
            </summary>
            <param name="factLabel">The label of the Fact to retrieve.</param>
            <returns>The Fact that matches the label if it exists, otherwise null.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Assert(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Asserts (adds) a Fact in the current working memory.
            </summary>
            <param name="fact">The Fact to assert.</param>
            <returns>True if the Fact was added to the Fact Base, i.e. if it was really new!</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Retract(System.String)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to retract.</param>
            <returns>True if the Fact has been retracted from the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Retract(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="fact">The Fact to retract.</param>
            <returns>True if the Fact has been retracted from the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Modify(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFact">The Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.Modify(System.String,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFactLabel">The label of the Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.RunQuery(NxBRE.InferenceEngine.Rules.Query)">
            <summary>
            Runs a new Query in the current working memory.
            </summary>
            <remarks>
            For performance reasons, it is recommended to declare all queries in the rule base
            and to use RunQuery(queryLabel)
            </remarks>
            <param name="query">The new Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.RunQuery(System.Int32)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryIndex">The query base index of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
            <remarks>It is recommanded to use labelled queries.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IInferenceEngine.RunQuery(System.String)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryLabel">The label of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="E:NxBRE.InferenceEngine.IInferenceEngine.NewFactHandler">
            <summary>
            The event to subscribe in order to be notified of assertion of facts.
            </summary>
        </member>
        <member name="E:NxBRE.InferenceEngine.IInferenceEngine.DeleteFactHandler">
            <summary>
            The event to subscribe in order to be notified of retraction of facts.
            </summary>
        </member>
        <member name="E:NxBRE.InferenceEngine.IInferenceEngine.ModifyFactHandler">
            <summary>
            The event to subscribe in order to be notified of modification of facts.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.BinderType">
            <summary>
            The optional business object binder type (null if none).
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Direction">
            <summary>
            The direction of the loaded rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Label">
            <summary>
            The label of the loaded rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.WorkingMemoryType">
            <summary>
            The current type of working memory.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Initialized">
            <summary>
            Returns true if the engine is initialized with a valid rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.FactsCount">
            <summary>
            Gets the number of facts in the current working memory.
            </summary>
            <returns>The number of facts in the current working memory.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Facts">
            <summary>
            Gets an enumeration of the facts contained in the working memory.
            </summary>
            <returns>An IEnumerator on the facts contained in the working memory.</returns>
            <remarks>Do not alter the facts from this enumemration: use retract and modify instead.</remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.QueriesCount">
            <summary>
            Gets the number of queries in the current rulebase.
            </summary>
            <returns>The number of queries in the current rulebase.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Queries">
            <summary>
            Gets an enumeration of the queries in the current rulebase.
            </summary>
            <returns>An IEnumerator on the queries in the current rulebase.</returns>
            <remarks>Do not try to alter the queries from this enumemration: unexpected results might occur if you do so.</remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.QueryLabels">
            <summary>
            Gets the labels of the queries in the current rulebase.
            </summary>
            <returns>An <code>IList&lt;string></code> containing the labels of all the queries in the current rulebase.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.ImplicationsCount">
            <summary>
            Gets the number of implications in the current rulebase.
            </summary>
            <returns>The number of implications in the current rulebase.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IInferenceEngine.Implications">
            <summary>
            Gets an enumeration of the implications in the current rulebase.
            </summary>
            <returns>An IEnumerator on the implications in the current rulebase.</returns>
            <remarks>Do not try to alter the implications from this enumemration: unexpected results might occur if you do so.</remarks>
        </member>
        <member name="F:NxBRE.InferenceEngine.IEImpl.iterationLimit">
            <summary>
            The maximum number of iteration to perform in one process cycle. If this limit is reached, the engine will throw an exception.
            </summary>
            <remarks>The default is 1000.</remarks>
        </member>
        <member name="F:NxBRE.InferenceEngine.IEImpl.strictImplication">
            <summary>
            Defines whether the engine should throw an exception in case an implication
            tries to assert a fact whose variable predicates have not all be resolved
            by the data returned by the atoms of the body.
            </summary>
            <remarks>The default is false.</remarks>
        </member>
        <member name="F:NxBRE.InferenceEngine.IEImpl.lockTimeOut">
            <summary>
            The time-out in millisecond for acquiring a lock when hot swapping a rule base
            in multi-threaded environments.
            </summary>
            <remarks>The default is 15000.</remarks>
        </member>
        <member name="F:NxBRE.InferenceEngine.IEImpl.exposeEventContext">
            <summary>
            Defines if the events raised by the engine should contain the context,
            i.e. the source facts, implied in the event.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.#ctor">
            <summary>
            Instantiates a new Inference Engine with single-thread support.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.#ctor(NxBRE.InferenceEngine.ThreadingModelTypes)">
            <summary>
            Instantiates a new Inference Engine with the specified threading model.
            </summary>
            <param name="threadingModelType">The threading model type that the engine must support.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.#ctor(NxBRE.InferenceEngine.IO.IBinder)">
            <summary>
            Instantiates a new Inference Engine with single-thread support, using a business objects binder for asserting facts and evaluating functions.
            </summary>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.#ctor(NxBRE.InferenceEngine.IO.IBinder,NxBRE.InferenceEngine.ThreadingModelTypes)">
            <summary>
            Instantiates a new Inference Engine with the specified threading model, using a business objects binder for asserting facts and evaluating functions.
            </summary>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
            <param name="threadingModelType">The threading model type that the engine must support.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter)">
            <summary>
            Loads a rule base and process the performatives. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            This is equivalent to calling: <code>LoadRuleBase(adapter, true)</code>
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,NxBRE.InferenceEngine.IO.IBinder)">
            <summary>
            Loads a rule base and process the performatives. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            This is equivalent to calling: <code>LoadRuleBase(adapter, businessObjectsBinder, true)</code>
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,System.Boolean)">
            <summary>
            Loads a rule base. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="processPerformatives">Immediatly process the performative actions (assert, retract) found in the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.LoadRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter,NxBRE.InferenceEngine.IO.IBinder,System.Boolean)">
            <summary>
            Loads a rule base. The working memory is reset (all facts are lost).
            </summary>
            <param name="adapter">The Adapter used to read the rule base.</param>
            <param name="businessObjectsBinder">The business object binder that the engine must use.</param>
            <param name="processPerformatives">Immediatly process the performative actions (assert, retract) found in the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.SaveRuleBase(NxBRE.InferenceEngine.IO.IRuleBaseAdapter)">
            <summary>
            Saves the WorkingMemory in a rule base.
            </summary>
            <param name="adapter">The Adapter used to save the rule base.</param>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.LoadFacts(NxBRE.InferenceEngine.IO.IFactBaseAdapter)">
            <summary>
            Load facts in the current working memory. Current implications, facts and queries
            remain unchanged.
            </summary>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <param name="adapter">The Adapter used to read the fact base.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.SaveFacts(NxBRE.InferenceEngine.IO.IFactBaseAdapter)">
            <summary>
            Save facts of the current working memory. Current implications, facts and queries
            remain unchanged.
            </summary>
            <remarks>
            The adapter will be disposed at the end of the method's execution.
            </remarks>
            <param name="adapter">The Adapter used to save the fact base.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.NewWorkingMemory(NxBRE.InferenceEngine.WorkingMemoryTypes)">
            <summary>
            Sets the WorkingMemory of the engine, either by forking the existing Global memory
            to a new Isolated one, or by simply using the Global one.
            </summary>
            <param name="memoryType">The new type of working memory.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.CommitIsolatedMemory">
            <summary>
            Makes the current isolated memory the new global memory and sets the working memory
            type to global. Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.DisposeIsolatedMemory">
            <summary>
            Dispose the current isolated memory sets the working memory type to global.
            Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Process">
            <summary>
            Process all the performative and connective rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            This is equivalent to calling: <code>Process(ProcessModes.All)</code>
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Process(NxBRE.InferenceEngine.RuleTypes)">
            <summary>
            Process the selected rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <param name="ruleType">The particular rule type to process.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Process(System.Collections.IDictionary)">
            <summary>
            Process all the performative and connective rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            This is equivalent to calling: <code>Process(businessObjects, ProcessModes.All)</code>
            If businessObjects is Null, this method performs the same operation as <code>Process()</code>
             ; else it uses the binder provided in the constructor to perform fact operations and
            orchestrate the process.
            If businessObjects is not Null and no binder has been provided in the constructor, it throws
            a BREException.
            </remarks>
            <param name="businessObjects">An IDictionary of business objects, or Null.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Process(System.Collections.IDictionary,NxBRE.InferenceEngine.RuleTypes)">
            <summary>
            Process the selected rules on the current working memory and stops
            infering when no new Fact is deducted or retracted.
            </summary>
            <remarks>
            If businessObjects is Null, this method performs the same operation as <code>Process()</code>
             ; else it uses the binder provided in the constructor to perform fact operations and
            orchestrate the process.
            If businessObjects is not Null and no binder has been provided in the constructor, it throws
            a BREException.
            </remarks>
            <param name="businessObjects">An IDictionary of business objects, or Null.</param>
            <param name="ruleType">The particular rule type to process.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.FactExists(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="fact">The Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.FactExists(System.String)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.GetFact(System.String)">
            <summary>
            Returns a Fact from its label if it exists, else returns null.
            </summary>
            <param name="factLabel">The label of the Fact to retrieve.</param>
            <returns>The Fact that matches the label if it exists, otherwise null.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Assert(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Asserts (adds) a Fact in the current working memory.
            </summary>
            <param name="fact">The Fact to assert.</param>
            <returns>True if the Fact was added to the Fact Base, i.e. if it was really new!</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Retract(System.String)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to retract.</param>
            <returns>True if the Fact has been retracted from the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Retract(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="fact">The Fact to retract.</param>
            <returns>True if the Fact has been retracted from the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Modify(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFact">The Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.Modify(System.String,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFactLabel">The label of the Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.RunQuery(NxBRE.InferenceEngine.Rules.Query)">
            <summary>
            Runs a new Query in the current working memory.
            </summary>
            <remarks>
            For performance reasons, it is recommended to declare all queries in the rule base
            and to use RunQuery(queryLabel)
            </remarks>
            <param name="query">The new Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.RunQuery(System.Int32)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryIndex">The query base index of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
            <remarks>It is recommanded to use labelled queries.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IEImpl.RunQuery(System.String)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryLabel">The label of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="E:NxBRE.InferenceEngine.IEImpl.NewFactHandler">
            <summary>
            The event to subscribe in order to be notified of assertion of facts.
            </summary>
        </member>
        <member name="E:NxBRE.InferenceEngine.IEImpl.DeleteFactHandler">
            <summary>
            The event to subscribe in order to be notified of retraction of facts.
            </summary>
        </member>
        <member name="E:NxBRE.InferenceEngine.IEImpl.ModifyFactHandler">
            <summary>
            The event to subscribe in order to be notified of modification of facts.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Binder">
            <summary>
            The optional business object binder (null if none).
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.BinderType">
            <summary>
            The optional business object binder type (null if none).
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Direction">
            <summary>
            The direction of the loaded rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Label">
            <summary>
            The label of the loaded rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.WorkingMemoryType">
            <summary>
            The current type of working memory.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Initialized">
            <summary>
            Returns true if the engine is initialized with a valid rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.FactsCount">
            <summary>
            Gets the number of facts in the current working memory.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Facts">
            <summary>
            Gets an enumeration of the facts contained in the working memory.
            </summary>
            <returns>An IEnumerator on the facts contained in the working memory.</returns>
            <remarks>Do not alter the facts from this enumemration: use retract and modify instead.</remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.QueriesCount">
            <summary>
            Gets the number of queries in the current rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Queries">
            <summary>
            Gets an enumeration of the queries in the current rulebase.
            </summary>
            <returns>An IEnumerator on the queries in the current rulebase.</returns>
            <remarks>Do not try to alter the queries from this enumemration: unexpected results might occur if you do so.</remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.QueryLabels">
            <summary>
            Gets the labels of the queries in the current rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.ImplicationsCount">
            <summary>
            Gets the number of implications in the current rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IEImpl.Implications">
            <summary>
            Gets an enumeration of the implications in the current rulebase.
            </summary>
            <returns>An IEnumerator on the implications in the current rulebase.</returns>
            <remarks>Do not try to alter the implications from this enumemration: unexpected results might occur if you do so.</remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.RuleTypes">
            <summary>
            The available types of rules to process.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.RuleTypes.PerformativesOnly">
            <summary>
            Only process performatives, i.e. only perform assertions and retraction as defined in the loaded rule base.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.RuleTypes.ConnectivesOnly">
            <summary>
            Only process connectives, i.e. only run implications defined in the loaded rule base.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.RuleTypes.All">
            <summary>
            Process performatives and connectives.
            </summary>
            <remarks>
            This is the default mode of the Inference Engine.
            </remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.IntegrityException">
            <summary>
            An exception thrown by the engine when an integrity error has been detected.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IntegrityException.#ctor(System.String)">
            <summary> Instantiates a new IntegrityException with a specific message</summary>
            <param name="message">The error message</param>
        </member>
        <member name="T:NxBRE.InferenceEngine.NewFactEvent">
            <summary>
            Delegate for listening new events for Facts. This class is immutable.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.NewFactEventArgs">
            <summary>
            New Fact event definition.
            </summary>
            <remarks>
            DO NOT ASSERT OR RETRACT FACTS OR ALTER THE EVENT CONTEXT WHEN HANDLING THIS EVENT!
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.NewFactEventArgs.#ctor(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Instantiates a new Fact event definition.
            </summary>
            <remarks>
            DO NOT ASSERT OR RETRACT FACTS WHEN HANDLING THIS EVENT!
            </remarks>
            <param name="fact">The Fact that generated the event.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.NewFactEventArgs.#ctor(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.IEventContext)">
            <summary>
            Instantiates a new Fact event definition.
            </summary>
            <remarks>
            DO NOT ASSERT OR RETRACT FACTS WHEN HANDLING THIS EVENT!
            </remarks>
            <param name="fact">The Fact that generated the event.</param>
            <param name="context">The context of the event.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.NewFactEventArgs.#ctor(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Instantiates a new Fact event definition.
            </summary>
            <remarks>
            DO NOT ASSERT OR RETRACT FACTS WHEN HANDLING THIS EVENT!
            </remarks>
            <param name="fact">The Fact that generated the event.</param>
            <param name="otherFact">The Other Fact that generated the event.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.NewFactEventArgs.#ctor(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.IEventContext)">
            <summary>
            Instantiates a new Fact event definition.
            </summary>
            <remarks>
            DO NOT ASSERT OR RETRACT FACTS WHEN HANDLING THIS EVENT!
            </remarks>
            <param name="fact">The Fact that generated the event.</param>
            <param name="otherFact">The Other Fact that generated the event.</param>
            <param name="context">The context of the event.</param>
        </member>
        <member name="P:NxBRE.InferenceEngine.NewFactEventArgs.Context">
            <summary>
            The context in which the event happened.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.NewFactEventArgs.Fact">
            <summary>
            The fact that has generated the event.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.NewFactEventArgs.OtherFact">
            <summary>
            The optional other fact involved in the event, or null.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.AbstractChainManager">
            <summary>Abstract class for managing chains of implications engaged in relationships
             like in mutex or pre-conditions.</summary>
             <remarks>Core classes are not supposed to be used directly.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.AbstractWorkingMemory">
            <summary>
            The WorkingMemory is the core class of the inference engine.
            </summary>	
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.IWorkingMemory">
            <summary>
            The WorkingMemory is the core class of the inference engine.
            It contains references to the FactBase.
            </summary>	
            <description>
            The WorkingMemory supports two types: Global and Isolated.
            It is important to understand that Isolated memory is forked from the Global memory.
            Isolated memory is usefull in multi-threaded environments, where the engine must run
            a common base of implications/facts against facts specific to each thread.
            </description>
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.Agenda">
            <summary>
             The agenda is the "maestro" of the inference engine.
             It manages the scheduling of the implication and provides them to the engine 
             ordered by their weigth.
             </summary>
             <remarks>Core classes are not supposed to be used directly.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.Agenda.Schedule(NxBRE.InferenceEngine.Rules.Implication)">
            <summary>
            Schedule a single implication.
            </summary>
            <param name="implication">The implication to schedule.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.Agenda.Schedule(System.Collections.Generic.IList{NxBRE.InferenceEngine.Rules.Implication},NxBRE.InferenceEngine.Core.ImplicationBase)">
            <summary>
            Schedule all implications that are listening the facts in the fact base
            except if no new fact of the listening type where asserted in the previous iteration.
            </summary>
            <param name="positiveImplications">Null if it is the first iteration, else en ArrayList of positive implications of current iteration.</param>
            <param name="IB">The current ImplicationBase.</param>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.FactBase">
            <summary>
            The FactBase is the repository of facts for the inference engine.
            This implementation does not allow duplicated facts.
            </summary>
            <remarks>This class is not thread safe.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.NAF">
            <summary>
            A pre-instantiated negative fact.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.EMPTY_SELECT_RESULT">
            <summary>
            A pre-instantiated empty list of fact for using as a select result.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.predicateMap">
            <summary>
            The main storage of facts, hierarchized on Signature, Predicate Value Type, Predicate Value and Predicate Position
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.signatureMap">
            <summary>
            A secondary fact storage, used for direct access for a particular signature.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.factListReferences">
            <summary>
            An inverted index allowing to discover all the lists where a particular fact is referenced (for fast removal)
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.labelMap">
            <summary>
            A storage of facts based on their optional labels.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.strictTyping">
            <summary>
            Defines whether the fact storage should consider typed objects as equivalent to their String representation.
            If StrictTyping is set to true, they are will not be considered equivalent. The default is false.
            </summary>
            <remarks>
            It is internal to allow changing it for unit testing purposes.
            </remarks>
        </member>
        <member name="F:NxBRE.InferenceEngine.Core.FactBase.modifiedFlag">
            <summary>
            A flag that external class can use to detect fact assertions/retractions.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.#ctor">
            <summary>
            Instantiates a new fact base.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.GetEnumerator">
            <summary>
            Gets the enumeration of all facts in the fact base.
            </summary>
            <returns>An IEnumerator of all facts.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets the enumeration of all facts in the fact base.
            </summary>
            <returns>An IEnumerator of all facts.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Clone">
            <summary>Clones the fact base.</summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Assert(NxBRE.InferenceEngine.Rules.Fact)">
            <remarks>As Facts labels are basically ignored (no retrieval nor any operation based
             on it, the FactBase does not bother check if we have different facts with same labels.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Retract(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Retracts (removes) a Fact from the FactBase.
            </summary>
            <param name="fact">The Fact to remove.</param>
            <returns>True if the Fact has been retracted from the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Modify(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFact">The Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Exists(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Checks if the FactBase contains a certain Fact.
            </summary>
            <param name="fact">The Fact to check.</param>
            <returns>True if the Fact is already present in the FactBase, otherwise False.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.GetFact(System.String)">
            <summary>
            Gets a certain Fact out of the FactBase from its Label.
            </summary>
            <param name="factLabel">The label of the Fact to get.</param>
            <returns>The Fact matching the label if present in the FactBase, otherwise null.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ToString">
            <summary>
            A String representation of the FactBase for display purpose only.
            </summary>
            <returns>The String representation of the FactBase.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.HasFactsForSignature(System.String)">
            <summary>
            Checks if there is at least one fact matching a particular signature
            </summary>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.RunQuery(NxBRE.InferenceEngine.Rules.Query)">
            <summary>
            Runs a Query against a the FactBase.
            </summary>
            <param name="query">The Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing references to facts matching the pattern of the Query.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ExtractAllFacts(System.Collections.Generic.IList{System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult}})">
            <summary>
            Extract all the facts found in process results.
            </summary>
            <param name="processResults">The process results from which facts must be extracted.</param>
            <returns>An <code>IList&lt;Fact></code> of extracted facts.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ExtractFacts(System.Collections.Generic.IList{System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult}})">
            <summary>
            Extract the facts found in process results and return them as a standard query result.
            </summary>
            <param name="processResults">The process results from which facts must be extracted.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> of extracted facts.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ExtractFacts(System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult})">
            <summary>
            Extract the facts found in one row of a process results and return them as one row of a standard query result.
            </summary>
            <param name="processResult">One row of process results from which facts must be extracted.</param>
            <returns>An <code>IList&lt;Fact></code></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ProcessAtomGroup(NxBRE.InferenceEngine.Rules.AtomGroup)">
            <summary>
            Runs an AtomGroup against the FactBase.
            </summary>
            <remarks>
            Each Atom in the group and sub-groups must have been registered.
            </remarks>
            <param name="AG">The AtomGroup to execute</param>
            <returns>An <code>IList&lt;IList&lt;PositiveMatchResult>></code> object containing the results.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Populate(NxBRE.InferenceEngine.Rules.Atom,System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult},System.Boolean)">
            <summary>
            Replaces non-fixed elements of an atom (variables, formulas...) with fixed values (individuals) when possible
            </summary>
            <param name="targetAtom"></param>
            <param name="resultStack"></param>
            <param name="evaluateFormulas"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.EnrichResults(System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult},NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Add a result (and its producing atom) in a result stack. 
            </summary>
            <param name="resultStack">An ArrayList containing the results to enrich.</param>
            <param name="source">The atom that has produced the fact to add</param>
            <param name="result">The fact to add to the result stack.</param>
            <returns>An arraylist containing the original result stack enriched by the new fact.</returns>
            <remarks>The new fact is added at the top of the result stack, to give it maximum priority in further processing.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.BuildQueryFromDeduction(NxBRE.InferenceEngine.Rules.Atom,System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult})">
            <summary>
            Build an atom for querying facts on the basis of an implication deduction, whose individual
            predicates will be replaced by variables and whose variables will be resolved from values
            coming from an implication result stack.
            </summary>
            <param name="targetAtom">The implication deduction atom.</param>
            <param name="resultStack">The implication result stack.</param>
            <returns>The atom ready for querying facts.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.StoreFactForIndividualValue(NxBRE.InferenceEngine.Rules.Fact,System.Int32,System.Object)">
            <summary>
            Store the fact in the map, hierarchized on its signature, predicate type, predicate value
            and predicate position
            </summary>
            <param name="fact"></param>
            <param name="predicatePosition"></param>
            <param name="individualValue"></param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.AddFactListReference(NxBRE.InferenceEngine.Rules.Fact,System.Collections.Generic.ICollection{NxBRE.InferenceEngine.Rules.Fact})">
            <summary>
            Remembers that a fact has been refered to in a particular list, which will allow convenient and fast removal.
            </summary>
            <param name="fact"></param>
            <param name="listReference"></param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.Select(NxBRE.InferenceEngine.Rules.Atom,System.Collections.Generic.IList{NxBRE.InferenceEngine.Rules.Fact})">
            <summary>
            Gets a list of facts matching a particular atom.
            </summary>
            <param name="filter">The atom to match</param>
            <param name="excludedFacts">A list of facts not to return, or null</param>
            <returns>An IList containing the matching facts (empty if no match, but never null).</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.FilterDistinct(System.Collections.Generic.IList{System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult}})">
            <summary>
            Performs the equivalent of a SQL select distinct where a rows of data will be lists of PositiveMatchResult.
            </summary>
            <param name="processResults"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ProcessAnd(NxBRE.InferenceEngine.Rules.AtomGroup,System.Collections.Generic.IList{System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult}},System.Int32,System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult})">
            <summary>
            Processes an AND atom group.
            </summary>
            <param name="AG"></param>
            <param name="processResult"></param>
            <param name="depth"></param>
            <param name="resultStack"></param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ProcessOr(NxBRE.InferenceEngine.Rules.AtomGroup,System.Collections.Generic.IList{System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult}},System.Collections.Generic.IList{NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult})">
            <summary>
            Processes an OR atom group.
            </summary>
            <param name="AG"></param>
            <param name="processResult"></param>
            <param name="resultStack"></param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.FactBase.ProcessAtom(NxBRE.InferenceEngine.Rules.Atom,System.Collections.Generic.IList{NxBRE.InferenceEngine.Rules.Fact})">
            <summary>
            Processes an atom.
            </summary>
            <param name="atomToRun"></param>
            <param name="excludedFacts"></param>
            <returns></returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Core.FactBase.Count">
            <summary>
            The total number of facts in the fact base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Core.FactBase.ModifiedFlag">
            <summary>
            A flag that external class can use to detect new fact assertions. The fact base sets
            this fact to True if it is false and a new fact has been asserted and accepted.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.FactBase.NegativeFact">
            <summary>
            A technical subclass of Fact for representing a positive negative-fact!
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Fact">
            <summary>
            A Fact is a specialization of Atom, which can be labelled and
            contains only Individual predicates. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Atom">
            <summary>
            An Atom represents a typed association of predicates. It is immutable (because predicates are immutable so Members will not vary).
            </summary>
            <remarks>The Atom supports the method for data pattern matching that are the core of
            the forward-chaining (data driven) inference engine.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.#ctor(System.String,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Instantiates a new Positive (non-NAF) non-function Relation Atom.
            </summary>
            <param name="type">Type of the Atom.</param>
            <param name="members">Array of predicates associated in the Atom.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.#ctor(System.Boolean,System.String,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Instantiates a new Atom.
            </summary>
            <param name="negative">Negative Atom.</param>
            <param name="type">The relation type of the Atom.</param>
            <param name="members">Array of predicates associated in the Atom.</param>
            <remarks>This is the principal constructor for Atom and descendant objects.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.#ctor(NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Protected constructor used for cloning purpose.
            </summary>
            <param name="source">The atom to use as a template.</param>
            <param name="members">The members to use instead of the ones in the source, or null if the ones of the source must be used.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.#ctor(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Protected constructor used for cloning purpose.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.Clone">
            <summary>
            Returns a cloned Atom, of same type and containing a clone of the array of predicates.
            </summary>
            <returns>A new Atom, based on the existing one.</returns>
            <remarks>The predicates are not cloned.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.CloneWithNewMembers(NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Performs a clone of the current Atom but substitute members with the provided ones.
            </summary>
            <param name="members">New members to use.</param>
            <returns>A clone with new members.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.BasicMatches(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Checks if the signature of the current Atom matches with the signature of another one.
            </summary>
            <param name="atom">The other atom to determine the signature matching.</param>
            <returns>True if the two atoms have the same signature, False otherwise.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.PredicatesMatch(NxBRE.InferenceEngine.Rules.Atom,System.Boolean,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Checks if the predicates of the current Atom match with the predicates of another one, i.e. are equal or functions resolve to True.
            </summary>
            <param name="atom">The other atom to determine the predicates matching.</param>
            <param name="strictTyping">True if String individual predicate are not considered as potential representations of other types.</param>
            <param name="ignoredPredicates">A list of predicate positions to exclude from comparison, or null if all predicates must be matched</param>
            <returns>True if the two atoms have matching predicates, False otherwise.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.Matches(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Checks if the current Atom matches with another one, i.e. if they are of same type,
            contain the same number of predicates, and if their Individual predicates are equal.
            </summary>
            <description>
            This functions takes care of casting as it always tries to cast to the strongest type
            of two compared individuals. Since predicates can come from weakly-typed rule files
            (Strings) and other predicates can be generated by the user, this function tries to
            convert from String to the type of the other predicate (as String is considered not
            strongly typed).
            </description>
            <param name="atom">The other atom to determine the matching.</param>
            <returns>True if the two atoms match.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.IsIntersecting(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Check if the current intersects with another one, which means that:
             - they Match() together,
             - their predicate types are similar,
             - if there are variables, at least one should be equal to the corresponding one.
            </summary>
            <param name="atom">The other atom to determine the intersection.</param>
            <returns>True if the two atoms intersect.</returns>
            <remarks>IsIntersecting calls Matches first.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.ToString">
            <summary>
            Returns the String representation of the Atom for display purpose only.
            </summary>
            <remarks>
            If the Inference Engine trace switch is Verbose, the type of non String predicates will be shown.
            </remarks>
            <returns>The String representation of the Atom.</returns>
            <see cref="M:NxBRE.InferenceEngine.Rules.Atom.ToString(System.Boolean)"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.ToString(System.Boolean)">
            <summary>
            Returns the String representation of the Atom for display purpose only.
            </summary>
            <param name="outputType">If True, the type of non String predicates will be displayed</param>
            <returns>The String representation of the Atom.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.Equals(System.Object)">
            <summary>
            Checks if the current Atom is equal to another one, based on their type and predicates.
            </summary>
            <param name="o">The other Atom to test the equality.</param>
            <returns>True if the two atoms are equal.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.GetHashCode">
            <summary>
            Calculates the hashcode of the current Atom.
            </summary>
            <returns>The hashcode of the current Atom.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.GetPredicateValue(System.Int32)">
            <summary>
            A helper method for easily reaching a member predicate value from its index.
            </summary>
            <param name="predicateIndex">The index of the predicate in the array of Members.</param>
            <returns>The actual value of the predicate, or throws an exception if the index is out of range.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.GetPredicateValue(System.String)">
            <summary>
            A helper method for easily reaching a member predicate value from its slot name.
            </summary>
            <param name="slotName">The name of the slot in which the predicate is stored</param>
            <returns>The actual value of the predicate, or throws an exception if no slot matches the name.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Atom.GetPredicate(System.String)">
            <summary>
            A helper method for easily reaching a member predicate from its slot name.
            </summary>
            <param name="slotName">The name of the slot in which the predicate is stored</param>
            <returns>The predicate or null if no slot matches the name.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.Negative">
            <summary>
            Negative fact.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.Type">
            <summary>
            The type of Atom.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.Members">
            <summary>
            The array of predicates associated in the Atom.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.SlotNames">
            <summary>
            The array of slot names in the Atom. Non-named members have a String.Empty slot name.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.HasSlot">
            <summary>
            Returns True if there is at least one Slot in the members.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.IsFact">
            <summary>
            Checks if the current Atom is a Fact by analyzing the predicates.
            </summary>
            <description>A Fact is an association of predicates of type Individual.</description>
            <returns>True if the Atom is a Fact.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.HasFunction">
            <summary>
            Returns True if there is at least one Function predicate in the members.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.HasFormula">
            <summary>
            Returns True if there is at least one Formula predicate in the members.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.HasIndividual">
            <summary>
            Returns True if there is in the members at least one Individual predicate.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.HasVariable">
            <summary>
            Returns True if there is in the members at least one Variable predicate.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.Signature">
            <summary>
            A String signature used for internal purposes
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.OnlyVariables">
            <summary>
            Returns True is the members are only Variable predicates.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Atom.PredicateValues">
            <summary>
            A helper accessor for easily getting the member predicate values.
            </summary>
            <returns>An array of objects containing the member predicate values.</returns>
            <remarks>
            This method is inefficient performance-wise and should be used wisely.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.#ctor(System.String,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Instantiates a new anonymous (not labelled) Fact based on a Type and an array of predicates.
            </summary>
            <param name="type">The Type of the new Fact.</param>
            <param name="members">The Array of predicates that the Fact will contain.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.#ctor(System.String,System.String,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Instantiates a new labelled Fact based on a Label, a Type and an array of predicates.
            </summary>
            <param name="label">The Label of the new Fact.</param>
            <param name="type">The Type of the new Fact.</param>
            <param name="members">The Array of predicates that the Fact will contain.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.#ctor(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Instantiates a new anonymous (not labelled) Fact based on an existing Atom.
            </summary>
            <param name="atom">The Atom that the fact will be built on.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.#ctor(System.String,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Instantiates a new labelled Fact based on an existing Atom and a provided Label.
            </summary>
            <param name="label">The Label of the new Fact.</param>
            <param name="atom">The Atom that the Fact will be built on.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.Clone">
            <summary>
            Returns a cloned Fact, of same label, type and containing a clone of the array of predicates.
            </summary>
            <returns>A new Fact, based on the existing one.</returns>
            <remarks>The predicates are not cloned.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.ChangeLabel(System.String)">
            <summary>
            Changes the label of a fact by building a new one with the new label (because it is immutable).
            </summary>
            <param name="newLabel">The new label to use.</param>
            <returns>A new Fact based on the current one and the provided new label.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Fact.CloneWithNewMembers(NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Performs a clone of the current Atom but substitute members with the provided ones.
            </summary>
            <param name="members">New members to use.</param>
            <returns>A clone with new members.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Fact.Label">
            <summary>
            The Label of the Fact.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.FactBase.PositiveMatchResult">
            <summary>
            A class representing one selected match between an atom and a fact
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.ImplicationBase">
            <summary>
            The ImplicationBase is the repository of implications for the inference engine.
            Implications are organized in sub-collections grouped by atom types for performance reasons.
            Each implication "listens" to specific facts, based on their signatures.
            </summary>
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.MutexManager">
            <summary>Class for managing chains of implications engaged in mutex relationships.
             It analyzes the consistency of the mutual exclusion references in implications.
             </summary>
             <remarks>Core classes are not supposed to be used directly.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.PreconditionManager">
            <summary>Class for managing chains of implications engaged in pre-condition relationships.
             It analyzes the consistency of the pre-condition references in implications.
             It also calculate the salience of each implication.
             </summary>
             <remarks>Core classes are not supposed to be used directly.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.QueryBase">
            <summary>
            The QueryBase is the repository of queries for the inference engine.
            Anonymous (unlabeled) queries can be accessed by their index in the query base.
            It is recommanded to name queries for obvious usability reasons.
            </summary>
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.ThreadSafeWorkingMemory">
            <summary>
            This is the ThreadSafe version of the WorkingMemory, which is the core class of the inference engine.
            It contains references to the FactBase.
            </summary>	
            <description>
            The WorkingMemory supports two types: Global and Isolated.
            It is important to understand that Isolated memory is forked from the Global memory.
            Isolated memory is usefull in multi-threaded environments, where the engine must run
            a common base of implications/facts against facts specific to each thread.
            </description>
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.WorkingMemory">
            <summary>
            The WorkingMemory is the core class of the inference engine.
            It contains references to the FactBase.
            </summary>	
            <description>
            The WorkingMemory supports two types: Global and Isolated.
            It is important to understand that Isolated memory is forked from the Global memory.
            </description>
            <remarks>Core classes are not supposed to be used directly.</remarks>
            <author>David Dossot</author>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Core.WorkingMemoryFactory">
            <summary>
            A factory for creating WorkingMemory objects.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AbstractBinder">
            <summary>
            Provides an abstract implementation of IBinder that implements the parameters
            and AnalyzeIndividualPredicate using a regular expression for detecting
            functions in Individual predicates.
            </summary>
            <see cref="T:NxBRE.InferenceEngine.IO.IBinder">IBinder definition.</see>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.IBinder">
            <summary>
            Defines a generalized binder object for connecting the rulebase and the business objects.
            It uses the inversion of control principle: the engine calls it when it is the right time.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.ControlProcess">
            <summary>
            If BindingType is Control, called by the Inference Engine instead of starting the inference
            process. It then belongs to the implementer to assert facts and start the processing.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.BeforeProcess">
            <summary>
            If BindingType is BeforeAfter, 
            called by the Inference Engine before starting the inference process. This is where
            the implementer should assert initial facts based on the business objects.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.AfterProcess">
            <summary>
            If BindingType is BeforeAfter, 
            called by the Inference Engine after finishing the inference process. This is where
            the implementer can perform results analysis or updates of business objects.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.Evaluate(System.Object,System.String,System.String[])">
            <summary>
            Called by the Inference Engine whenever a Function predicate must be evaluated.
            </summary>
            <param name="predicate">The predicate value to check the function against.</param>
            <param name="function">The function name defined in the rule base.</param>
            <param name="arguments">The function arguments defined in the rule base.</param>
            <returns>True if the predicate value matches the function.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.Relate(System.String,System.Object[])">
            <summary>
            Called by the Inference Engine whenever a Function atom relation must be evaluated.
            </summary>
            <param name="function">The function name defined in the rule base.</param>
            <param name="predicates">The predicates' values acting as function parameters.</param>
            <returns>True if the function relation is positive.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.Compute(System.String,System.Collections.IDictionary)">
            <summary>
            Called by the Inference Engine whenever a formula individual must be evaluated.
            </summary>
            <param name="operationName">The operation name defined in the rule base.</param>
            <param name="arguments">The arguments (name/value) used when evaluating the formula.</param>
            <returns>An object representing the value of the computed formula.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IBinder.AnalyzeIndividualPredicate(NxBRE.InferenceEngine.Rules.Individual)">
            <summary>
            Called by the Inference Engine whenever an Individual predicate is found in the
            rule base and must be evaluated to determine if it is a function.
            </summary>
            <param name="individual">The Individual found in the rule base.</param>
            <returns>The unchanged Individual if it is not a function, else a Function predicate.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.IEF">
            <summary>
            Gets or sets the Inference Engine Faade to use in the binder.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.BindingType">
            <summary>
            Gets or sets the binding type of the binder.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.BusinessObjects">
            <summary>
            Gets or sets the IDictionary of Business Objects, where the user is free to store whatever
            fits his requirements. The key represents the type of object and the value a business object
            or a collection of business objects of this type.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.OnNewFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a new fact is deducted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.OnDeleteFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a fact is deleted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IBinder.OnModifyFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a new fact is deducted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.AnalyzeIndividualPredicate(NxBRE.InferenceEngine.Rules.Individual)">
            <summary>
            Called by the Inference Engine whenever an Individual predicate is found in the
            rule base and must be evaluated to determine if it is a function.
            </summary>
            <param name="individual">The Individual found in the rule base.</param>
            <returns>The unchanged Individual if it is not a function, else a Function predicate.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.ControlProcess">
            <summary>
            If BindingType is Control, called by the Inference Engine instead of starting the inference
            process. It then belongs to the implementer to assert facts and start the processing.
            </summary>
            <remarks>
            This method is implemented in the Abstract class but does nothing, it is just for convenience
            if it is not needed.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.BeforeProcess">
            <summary>
            Called by the Inference Engine before starting the inference process. This is where
            the implementer should assert initial facts based on the business objects.
            </summary>
            <remarks>
            This method is implemented in the Abstract class but does nothing, it is just for convenience
            if it is not needed.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.AfterProcess">
            <summary>
            Called by the Inference Engine after finishing the inference process. This is where
            the implementer can perform results analysis or updates of business objects.
            </summary>
            <remarks>
            This method is implemented in the Abstract class but does nothing, it is just for convenience
            if it is not needed.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.Evaluate(System.Object,System.String,System.String[])">
            <summary>
            Called by the Inference Engine whenever a Function predicate must be evaluated.
            </summary>
            <param name="predicate">The predicate value to check the function against.</param>
            <param name="function">The function name defined in the rule base.</param>
            <param name="arguments">The function arguments defined in the rule base.</param>
            <returns>True if the predicate value matches the function.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.Compute(System.String,System.Collections.IDictionary)">
            <summary>
            Called by the Inference Engine whenever a formula individual must be evaluated.
            </summary>
            <param name="operationName">The operation name defined in the rule base.</param>
            <param name="arguments">The arguments (name/value) used when evaluating the formula.</param>
            <returns>An object representing the value of the computed formula.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractBinder.Relate(System.String,System.Object[])">
            <summary>
            Called by the Inference Engine whenever a Function atom relation must be evaluated.
            </summary>
            <param name="function">The function name defined in the rule base.</param>
            <param name="predicates">The predicates' values acting as function parameters.</param>
            <returns>True if the function relation is positive.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.RegexFunction">
            <summary>
            The Regex used to define if the String content of an Individual represents a Function.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.IEF">
            <summary>
            Gets or sets the Inference Engine Faade to use in the binder.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.BindingType">
            <summary>
            Gets or sets the binding type of the binder.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.BusinessObjects">
            <summary>
            Gets or sets the IDictionary of Business Objects, where the user is free to store whatever
            fits his requirements. The key represents the type of object and the value a business object
            or a collection of business objects of this type.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.OnNewFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a new fact is deducted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.OnDeleteFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a fact is deleted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractBinder.OnModifyFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a fact is modifed
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter">
            <summary>
            An abstract RuleML adapter that contains common methods for loading and saving rule bases.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.IRuleBaseAdapter">
            <summary>
            NxBRE Inference Engine rulebase adapter interface.
            The engine calls the properties in this order: Binder, Direction, Label, Queries, Implications, Facts.
            </summary>
            <description>Reading is supported by the getter of each member, while writing is supported by setters.
            The engine calls dispose at the end of the load or save operation.
            </description>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.IFactBaseAdapter">
            <summary>
            NxBRE Inference Engine factbase adapter interface.
            The engine calls the properties in this order: Binder, Direction, Binder, Facts.
            </summary>
            <description>Reading is supported by the getter of each member, while writing is supported by setters.
            The engine calls dispose at the end of the load or save operation.
            </description>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
            <author>David Dossot</author>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IFactBaseAdapter.Direction">
            <summary>
            Optional direction of the rulebase: forward, backward or bidirectional.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IFactBaseAdapter.Label">
            <summary>
            Optional label of the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IFactBaseAdapter.Facts">
            <summary>
            Collection containing all the facts in the factbase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IFactBaseAdapter.Binder">
            <summary>
            Returns an instance of the associated Binder or null.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IRuleBaseAdapter.Queries">
            <summary>
            Collection containing all the queries in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IRuleBaseAdapter.Implications">
            <summary>
            Collection containing all the implications in the rulebase.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML adapter for reading or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML adapter for reading or writing to an URI.
            In Read mode, the adapter tries to locate a flow engine binder definition file 
            by appending .xbre to the URI.
            </summary>
            <param name="uriRuleML">The URI to read rules from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.Dispose">
            <summary>
            Called when the adapter is no longer used.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.Init(System.IO.Stream,System.String,System.IO.FileAccess)">
            <remarks>in case of any failure, this will throw enough exceptions for the user to
             understand what is going wrong.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.IsExpressionBinder(NxBRE.InferenceEngine.IO.IBinder)">
            <summary>
            Returns true if the binder is an internal expression evaluation binder.
            </summary>
            <param name="binder">The binder to evaluate</param>
            <returns>True if internal binder</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.Binder">
            <summary>
            Sets the optionally associated IBinder or null.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.ImplicationProperties">
            <summary>
            Structure containing the Implication meta-informations stored in the label.
            This is an extension to RuleML, which allows to stay valid with the Schema and is conform
            to this remark from ruleml.org about label:
            "rule label is a handle for the imp: for various uses, including prioritization".
            </summary>
            <remarks>
            The struct was made public only for unit test purpose.
            </remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.ExpressionEvaluator">
            <summary>
            The ExpressionEvaluator is a private class that uses expression for performing binder "Evaluate".
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AbstractRuleMLAdapter.ExpressionRelater">
            <summary>
            The ExpressionRelater is a private class that uses expression for performing binder "Relate".
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.CSharpBinderFactory">
            <summary>
            This class is a helper for instantiating IBinder objects from CSharp files,
            giving the performance of a binder embedded in the main application and the
            flexibility of a file-based external binder.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.CSharpBinderFactory.LoadFromFile(System.String,System.String)">
            <summary>
            Instantiates a new IBinder class.
            </summary>
            <param name="binderClassName">The fully qualified class name of the binder class.</param>
            <param name="binderClassFileName">The full path of the file containing the C# source code of the class.</param>
            <returns>A new instance of IBinder based on the class definition.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.CSharpBinderFactory.LoadFromString(System.String,System.String)">
            <summary>
            Instantiates a new IBinder class.
            </summary>
            <param name="binderClassName">The fully qualified class name of the binder class.</param>
            <param name="binderClassSource">The C# source code of the class.</param>
            <returns>A new instance of IBinder based on the class definition.</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.FlowEngineBinder">
            <summary>
            Provides an implementation of IBinder that is based on AbstractBinder
            and uses the Flow Engine for asserting facts from the business objects
            and evaluating functions.
            
            The business rules used for the Flow Engine Binder must be valid with
            xBusinessRules.xsd.
            </summary>
            <remarks>
            The business object keys should not contain the reserved keys.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.#ctor(System.IO.Stream,NxBRE.InferenceEngine.IO.BindingTypes)">
            <summary>
            Instantiates a new FlowEngineBinder, using a stream for reading the business rules.
            </summary>
            <remarks>
            The business rules used for the binding must be valid with xBusinessRules.xsd.
            </remarks>
            <param name="stream">The Stream used to read the business rules from.</param>
            <param name="bindingType">The type of binding supported by this binder.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.#ctor(System.String,NxBRE.InferenceEngine.IO.BindingTypes)">
            <summary>
            Instantiates a new FlowEngineBinder, reading the business rules from a certain URI.
            </summary>
            <remarks>
            The business rules used for the binding must be valid with xBusinessRules.xsd.
            </remarks>
            <param name="uri">The URI from which the business rules must be read.</param>
            <param name="bindingType">The type of binding supported by this binder.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.ControlProcess">
            <summary>
            If BindingType is Control, called by the Inference Engine instead of starting the inference
            process. It then belongs to the implementer to assert facts and start the processing.
            </summary>
            <remarks>
            Object available in the Flow Engine context (ID = Description):
            NxBRE-IE = The inference engine faade.
            IE-GLOBALWM = WorkingMemoryTypes.Global,
            IE-ISOLATEDWM = WorkingMemoryTypes.Isolated.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.BeforeProcess">
            <summary>
            Called by the Inference Engine before starting the inference process. This is where
            the implementer should assert initial facts based on the business objects.
            </summary>
            <remarks>
            Object available in the Flow Engine context (ID = Description):
            NxBRE-IE = The inference engine faade.
            IE-GLOBALWM = WorkingMemoryTypes.Global,
            IE-ISOLATEDWM = WorkingMemoryTypes.Isolated.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.AfterProcess">
            <summary>
            Called by the Inference Engine after finishing the inference process. This is where
            the implementer can perform results analysis or updates of business objects.
            </summary>
            <remarks>
            Object available in the Flow Engine context (ID = Description):
            NxBRE-IE = The inference engine faade,
            IE-GLOBALWM = WorkingMemoryTypes.Global,
            IE-ISOLATEDWM = WorkingMemoryTypes.Isolated.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.Evaluate(System.Object,System.String,System.String[])">
            <summary>
            Called by the Inference Engine whenever a Function predicate must be evaluated.
            </summary>
            <remarks>
            Objects available in the Flow Engine context (ID = Description):
            NxBRE-IE     = The inference engine faade,
            Arg0..n      = The arguments passed to the function,
            IE-PREDICATE = The predicate to evaluate.
            
            Objects that must be placed in the context (ID = Description):
            IE-RESULT    = A boolean, True if the evaluation is positive.
            </remarks>
            <param name="predicate">The predicate value to check the function against.</param>
            <param name="function">The function name defined in the rule base.</param>
            <param name="arguments">The function arguments defined in the rule base.</param>
            <returns>True if the predicate value matches the function.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.Relate(System.String,System.Object[])">
            <summary>
            Called by the Inference Engine whenever a Function atom relation must be evaluated.
            </summary>
            <remarks>
            Objects available in the Flow Engine context (ID = Description):
            NxBRE-IE     = The inference engine faade,
            Arg0..n      = The arguments passed to the function.
            
            Objects that must be placed in the context (ID = Description):
            IE-RESULT    = A boolean, True if the evaluation is positive.
            </remarks>
            <param name="function">The function name defined in the rule base.</param>
            <param name="predicates">The predicates' values acting as function parameters.</param>
            <returns>True if the function relation is positive.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.Compute(System.String,System.Collections.IDictionary)">
            <summary>
            Called by the Inference Engine whenever a formula individual must be evaluated.
            </summary>
            <remarks>
            Objects available in the Flow Engine context (ID = Description):
            NxBRE-IE     = The inference engine faade,
            IE-ARGUMENTS = The IDictionary containing the arguments passed to the function.
            TYPEOF_PARAMETER_ID = The key used to extract the (possibily empty) IList of extra arguments.
            
            Objects that must be placed in the context (ID = Description):
            IE-RESULT    = An object, resulting of the computation.
            </remarks>
            <param name="operationName">The operation name defined in the rule base.</param>
            <param name="arguments">The arguments (name/value) used when evaluating the formula.</param>
            <returns>An object representing the value of the computed formula.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.HasFactEventHandler(System.String)">
            <summary>
            Checks if the binder must be called for each fact deducted or deleted while infering.
            </summary>
            <param name="eventType">The type of fact event.</param>
            <returns>True if the FlowEngineBinder should handle this type of fact event.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.FlowEngineBinder.EvaluateFERIOperator(System.String,System.Object[])">
            <summary>
            Faade for calling an NxBRE Flow Engine RI helper operator.
            </summary>
            <param name="functionName">The prefixed name of the helper operator to evaluate.</param>
            <param name="values">The arguments to pass to the operator.</param>
            <returns>True if the value matches the operator.</returns>
            <see cref="T:NxBRE.FlowEngine.IBREOperator"/>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.FlowEngineBinder.BusinessObjects">
            <summary>
            Gets or sets the IDictionary of Business Objects, where the user is free to store whatever
            fits his requirements. The key represents the type of object and the value a business object
            or a collection of business objects of this type.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.FlowEngineBinder.OnNewFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a fact is deducted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            
            Object available in the Flow Engine context (ID = Description):
            IE-NEWFACT = The new fact, source of the event.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.FlowEngineBinder.OnDeleteFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a fact is deleted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            
            Object available in the Flow Engine context (ID = Description):
            IE-DELETEDFACT = The deleted fact, source of the event.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.FlowEngineBinder.OnModifyFact">
            <summary>
            NewFactEvent delegate called by the Inference Engine whenever a new fact is deducted
            while infering. This is where the implementer can perform updates of business objects.
            </summary>
            <remarks>
            Return Null if no particular handling of the event is done.
            The implementer should refrain from performing any operation on the IEFacade object,
            like asserting new facts.
            
            Object available in the Flow Engine context (ID = Description):
            IE-MODIFIEDFACT = The modified fact.
            IE-MODIFIEDOTHERFACT = The new fact after modification.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.NewFactEventArgs">Definition of NewFactEventArgs.</see>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.FlowEngineBinder.FEBErrorListener">
            <summary>
            This listener has the only mission to stop the flow engine on any Error or Critical event
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.HRF086Adapter">
            <summary>Adapter supporting NxBRE-IE Human Readable Format (HRF) version 0.86.
             HRF is parsed and transformed to RuleML NafDatalog 0.86
             </summary>
            <remarks>US-ASCII is the only supported encoding.
             Var-less queries and implications are not supported.
             To be used in lieu of the previous (experimental) version HRF 0.8</remarks>
             <author>David Dossot</author>
             <author>Ron Evans</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter">
            <summary>Adapter supporting RuleML 0.86 NafDatalog Sublanguage.</summary>
            <remarks>UTF-8 is the default encoding.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.86 NafDatalog adapter for reading or writing to a stream.
            </summary>
            <remarks>
            By default, typed facts are not supported.
            </remarks>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.86 Datalog adapter for reading or writing to an URI.
            </summary>
            <remarks>
            By default, typed facts are not supported.
            </remarks>
            <param name="uriRuleML">The URI to read rules from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess,System.Boolean)">
            <summary>
            Instantiates a RuleML 0.86 NafDatalog adapter for reading or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="supportTypedFacts">If true, the adapter supports typed facts.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess,System.Boolean)">
            <summary>
            Instantiates a RuleML 0.86 Datalog adapter for reading or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read rules from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="supportTypedFacts">If true, the adapter supports typed facts.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.WriteAtom(System.Xml.XmlElement,NxBRE.InferenceEngine.Rules.Atom,System.Boolean)">
            <summary>Predicate persistence relies on ToString()
             Do not expect business object persistence with this adapter!</summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.Direction">
            <summary>
            Optional direction of the rulebase: forward, backward or bidirectional.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.RuleML086NafDatalogAdapter.Label">
            <summary>
            Optional label of the rulebase.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.HRF086Adapter.Dispose">
            <summary>
            Called when the adapter is no longer used.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.BindingTypes">
            <summary>
            The types of business object binding that determines the inversion of control
            calls, either:
            - BeforeProcess() and AfterProcess,
            or
            - ControlProcess().
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.BindingTypes.BeforeAfter">
            <summary>
            A binder that receives control before and after the inference process.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.BindingTypes.Control">
            <summary>
            A binder that receives full control and must start the inference process.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.IEFacade">
            <summary>
            A facade of the Inference Engine of NxBRE for usage from the object binder.
            </summary>
            <remarks>
            The facade provide some helper methods and hides forbidden methods, like Process(bo).
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.#ctor(NxBRE.InferenceEngine.IInferenceEngine)">
            <summary>
            Instantiates a new IEFacade that wraps an instance of the Inference Engine.
            </summary>
            <param name="ie">The Inference Engine the new facade must encapsulate.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.NewWorkingMemory(NxBRE.InferenceEngine.WorkingMemoryTypes)">
            <summary>
            Sets the WorkingMemory of the engine, either by forking the existing Global memory
            to a new Isolated one, or by simply using the Global one.
            </summary>
            <param name="memoryType">The new type of working memory.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.CommitIsolatedMemory">
            <summary>
            Makes the current isolated memory the new global memory and sets the working memory
            type to global. Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.DisposeIsolatedMemory">
            <summary>
            Dispose the current isolated memory sets the working memory type to global.
            Throws an exception in the current memory type is not isolated.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Process">
            <summary>
            Performs all the possible deductions on the current working memory and stops
            infering when no new Fact is deducted.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.AssertNewFact(System.String,System.Object[])">
            <summary>
            Asserts (adds) a new Fact in the current working memory.
            </summary>
            <remarks>
            This method is an helper of the regular Assert method that creates the Fact object directly.
            </remarks>
            <param name="type">The Type of the new Fact to assert.</param>
            <param name="individuals">The Individual predicatesthat the Fact will contain.</param>
            <returns>True if the Fact was added to the Fact Base, i.e. if it was really new!</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.AssertNewFactOrFail(System.String,System.Object[])">
            <summary>
            Asserts (adds) a new Fact in the current working memory, or throw a BREException if 
            the assertion failed, i.e. if the fact was already present.
            </summary>
            <remarks>
            This method is an helper of the regular Assert method that creates the Fact object directly.
            </remarks>
            <param name="type">The Type of the new Fact to assert.</param>
            <param name="individuals">The Individual predicatesthat the Fact will contain.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.NewFact(System.String,System.Object[])">
            <summary>
            Creates a new Fact.
            </summary>
            <remarks>
            This method is an helper of the regular Fact instantiation.
            </remarks>
            <param name="type">The Type of the new Fact to assert.</param>
            <param name="individuals">The Individual predicatesthat the Fact will contain.</param>
            <returns>A new Fact of desired Type and individuals.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.FactExists(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="fact">The Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.FactExists(System.String)">
            <summary>
            Returns true if a Fact exists in the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to check existence.</param>
            <returns>True if the Fact exists.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.GetFact(System.String)">
            <summary>
            Returns a Fact from its label if it exists, else returns null.
            </summary>
            <param name="factLabel">The label of the Fact to retrieve.</param>
            <returns>The Fact that matches the label if it exists, otherwise null.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Assert(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Asserts (adds) a Fact in the current working memory.
            </summary>
            <param name="fact">The Fact to assert.</param>
            <returns>True if the Fact was added to the Fact Base, i.e. if it was really new!</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Retract(System.String)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="factLabel">The label of the Fact to retract.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Retract(NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Retracts (removes) a Fact from the current working memory.
            </summary>
            <param name="fact">The Fact to retract.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Modify(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFact">The Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.Modify(System.String,NxBRE.InferenceEngine.Rules.Fact)">
            <summary>
            Modify a Fact by Retracting it and Asserting the replacement one.
            If the new Fact has no label (null or Empty), then the Label of the existing fact is kept.
            </summary>
            <param name="currentFactLabel">The label of the Fact to modify.</param>
            <param name="newFact">The Fact to modify to.</param>
            <returns>True if <term>currentFact</term> has been retracted from the FactBase, otherwise False ; this whether <term>newFact</term> already exists in the factbase, or not.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.RunQuery(NxBRE.InferenceEngine.Rules.Query)">
            <summary>
            Runs a new Query in the current working memory.
            </summary>
            <remarks>
            For performance reasons, it is recommended to declare all queries in the rule base
            and to use RunQuery(queryLabel)
            </remarks>
            <param name="query">The new Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.RunQuery(System.Int32)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryIndex">The query base index of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
            <remarks>It is recommanded to use labelled queries.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.RunQuery(System.String)">
            <summary>
            Runs a Query in the current working memory.
            </summary>
            <param name="queryLabel">The label of the Query to run.</param>
            <returns>An <code>IList&lt;IList&lt;Fact>></code> containing the results found.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.IEFacade.DispatchLog(System.String,System.Int32)">
            <summary>Method for logging messages</summary>
             <param name="message">The message to log</param>
             <param name="traceLevel">Trace level of the message</param>
             <see cref="T:System.Diagnostics.TraceLevel"/>
             <remarks></remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IEFacade.Label">
            <summary>
            The label of the loaded rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IEFacade.FactsCount">
            <summary>
            Gets the number of facts in the current working memory.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IEFacade.Facts">
            <summary>
            Gets an enumeration of the facts contained in the working memory.
            </summary>
            <returns>An IEnumerator on the facts contained in the working memory.</returns>
            <remarks>Do not alter the facts from this enumemration: use retract and modify instead.</remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.SaveFormatAttributes">
            <summary>
            Provides attributes for defining saving format of rule base
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.SaveFormatAttributes.Compact">
            <summary>
            Compact RuleML syntax.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.SaveFormatAttributes.Standard">
            <summary>
            Standard RuleML syntax.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.SaveFormatAttributes.Expanded">
            <summary>
            Expanded RuleML syntax.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.IO.SaveFormatAttributes.ForceDataTyping">
            <summary>
            Forces non-string individuals to be saved as XML Schema typed data, even if they were not defined as such in the
            original rulebase.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.IExtendedRuleBaseAdapter">
            <summary>
            NxBRE Inference Engine extended rulebase adapter interface.
            The engine calls the properties in this order: Binder, Direction, Label, Equivalents, Queries, Implications, Facts.
            </summary>
            <description>
            Reading is supported by the getter of each member, while writing is supported by setters.
            The engine calls dispose at the end of the load or save operation.</description>
            <remarks>
            This class is currently internal, it will be made public when stabilized, ie when RuleML 1.0 will be released.
            </remarks>
            <see cref="T:NxBRE.InferenceEngine.IEImpl"/>
            <author>David Dossot</author>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IExtendedRuleBaseAdapter.Assertions">
            <summary>
            Collection containing all the facts to assert.
            </summary>
            <remarks>
            This will make IFactBaseAdapter.Facts obsolete.
            </remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IExtendedRuleBaseAdapter.Retractions">
            <summary>
            Collection containing all the facts to retract.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IExtendedRuleBaseAdapter.Equivalents">
            <summary>
            Collection containing all the equivalent atom pairs in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.IExtendedRuleBaseAdapter.IntegrityQueries">
            <summary>
            Collection containing all the integrity queries.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.RuleML08DatalogAdapter">
            <summary>Adapter supporting RuleML 0.8 Datalog Sublanguage.</summary>
            <remarks>UTF-8 is the default encoding.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.RuleML086DatalogAdapter">
            <summary>Adapter supporting RuleML 0.86 Datalog Sublanguage.</summary>
            <remarks>UTF-8 is the default encoding.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086DatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.86 Datalog adapter for reading or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML086DatalogAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.86 Datalog adapter for reading or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read rules from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML08DatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.8 Datalog adapter for reading or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML08DatalogAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.8 Datalog adapter for reading or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read rules from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter">
            <summary>Adapter supporting RuleML 0.9 NafDatalog Sublanguage.</summary>
            <remarks>UTF-8 is the default encoding.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.9 NafDatalog adapter for reading from or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <remarks>
            By default, the standard syntax is used and non-typed individuals are not typified.
            When reading, all formats are automatically supported.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Instantiates a RuleML 0.9 NafDatalog adapter for reading from or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
            <remarks>When reading, all formats are automatically supported.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.9 NafDatalog adapter for reading from or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <remarks>
            By default, the standard syntax is used and non-typed individuals are not typified.
            When reading, all formats are automatically supported.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Instantiates a RuleML 0.9 Datalog adapter for reading from or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
            <remarks>When reading, all formats are automatically supported.</remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.Assertions">
            <summary>
            Collection containing all the facts to assert.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.RuleML09NafDatalogAdapter.Retractions">
            <summary>
            Collection containing all the facts to retract.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.Visio2003Adapter">
            <summary>Adapter supporting Visio 2003 DatadiagramML Format (VDX file).</summary>
             <remarks>Only READ is supported!</remarks>
             <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.#ctor(System.IO.Stream,System.IO.FileAccess,System.String[])">
            <summary>
            Instantiates a non-strict Visio 2003 DatadiagramML (VDX file) adapter for reading from a stream.
            It is possible to load only a selection of pages from the Visio file.
            </summary>
            <remarks>
            Only READ mode is supported!
            </remarks>
            <param name="streamVDX">The stream to read from.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="pageNames">An optional list of page names.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.#ctor(System.String,System.IO.FileAccess,System.String[])">
            <summary>
            Instantiates a non-strict Visio 2003 DatadiagramML (VDX file) adapter for reading from an URI.
            It is possible to load only a selection of pages from the Visio file.
            </summary>
            <remarks>
            Only READ mode is supported!
            </remarks>
            <param name="uriVDX">The URI to read from.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="pageNames">An optional list of page names.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.#ctor(System.IO.Stream,System.IO.FileAccess,System.Boolean,System.String[])">
            <summary>
            Instantiates a Visio 2003  (VDX file) adapter for reading from a stream.
            It is possible to load only a selection of pages from the Visio file.
            </summary>
            <remarks>
            Only READ mode is supported!
            </remarks>
            <param name="streamVDX">The stream to read from.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="strict">If true, the adapter expects the predicates to be strictly separated by commas.</param>
            <param name="pageNames">An optional list of page names.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.#ctor(System.String,System.IO.FileAccess,System.Boolean,System.String[])">
            <summary>
            Instantiates a Visio 2003 DatadiagramML (VDX file) adapter for reading from an URI.
            It is possible to load only a selection of pages from the Visio file.
            </summary>
            <remarks>
            Only READ mode is supported!
            </remarks>
            <param name="uriVDX">The URI to read from.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="strict">If true, the adapter expects the predicates to be strictly separated by commas.</param>
            <param name="pageNames">An optional list of page names.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.Dispose">
            <summary>
            Called when the adapter is no longer used.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.GetPageNames(System.String)">
            <summary>
            Returns a list of page names available in the specified Visio 2003 XML file.
            </summary>
            <param name="uriVDX">The URI to read from.</param>
            <returns>An array containing the Visio document page names.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.Visio2003Adapter.GetPageNames(System.IO.Stream)">
            <summary>
            Returns a list of page names available in the specified Visio 2003 XML file.
            </summary>
            <param name="streamVDX">The stream to read from.</param>
            <returns>An array containing the Visio document page names.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Direction">
            <summary>
            Optional direction of the rulebase: forward, backward or bidirectional.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Label">
            <summary>
            Optional label of the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Queries">
            <summary>
            Collection containing all the queries in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Implications">
            <summary>
            Collection containing all the implications in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Facts">
            <summary>
            Collection containing all the facts in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Assertions">
            <summary>
            Collection containing all the facts to assert.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Retractions">
            <summary>
            Collection containing all the facts to retract.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Equivalents">
            <summary>
            Collection containing all the equivalent atom pairs in the rulebase.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.IntegrityQueries">
            <summary>
            Collection containing all the integrity queries.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.IO.Visio2003Adapter.Binder">
            <summary>
            Returns an instance of the associated FlowEngineBinder or null.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Equivalent">
            <summary>
            An Equivalent is a pair of Atoms that are equivalent together, meaning that they can indiferently be used in Queries
            search expressions.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Equivalent.#ctor(NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Instantiates a new Equivalent pair of atoms.
            </summary>
            <param name="firstAtom">One of the atoms in the Equivalent pair.</param>
            <param name="secondAtom">The other atom of the Equivalent pair.</param>
            <remarks>This object is immutable</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Equivalent.#ctor(System.String,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Instantiates a new Equivalent pair of atoms.
            </summary>
            <param name="label">The optional label, or null if not needed.</param>
            <param name="firstAtom">One of the atoms in the Equivalent pair.</param>
            <param name="secondAtom">The other atom of the Equivalent pair.</param>
            <remarks>This object is immutable</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Equivalent.Get(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            If the passed atom matches one of the atoms in the Equivalent pair, returns the other atom, with its variable
            names modified to match the ones of the passed atom.
            </summary>
            <param name="atom">The atom that is potentially equivalent to one of the atoms of the Equivalent pair.</param>
            <returns>The atom equivalent to the passed one, or null if none of the atom pair is matching it.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Equivalent.ToString">
            <summary>
            A basic string representation of the equivalent, for display purposes only.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Equivalent.Label">
            <summary>
            The optional label of the Equivalent.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Equivalent.FirstAtom">
            <summary>
            One of the atoms in the Equivalent pair.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Equivalent.SecondAtom">
            <summary>
            The other atom of the Equivalent pair.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Formula">
            <summary>
            A Formula is a special predicate that represents an evaluation of a C# expression that produces a
            new individual predicate value (unlike Function that simply compare individuals).
            It can be used in a deduction atom only. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.AbstractPredicate">
            <summary>
            AbstractPredicate is the prototype for predicates. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.IPredicate">
            <summary>
             A Predicate is a cloneable unmutable object that returns a fixed value.
            </summary>
             <author>David Dossot</author>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.IPredicate.Value">
            <summary>
            The actual value of the Predicate.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AbstractPredicate.Value">
            <summary>
            The actual value of the Predicate.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Formula.#ctor(NxBRE.InferenceEngine.Rules.Formula.FormulaResolutionType,NxBRE.InferenceEngine.IO.IBinder,System.String)">
            <summary>
            Instantiates a new Formula predicate.
            </summary>
            <param name="resolutionType">The type of resolution for the formula.</param>
            <param name="bob">The business object binder to use when evaluating the formula, or null.</param>
            <param name="expression">The expression value, i.e. the C# code source that should be computable.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Formula.#ctor(NxBRE.InferenceEngine.Rules.Formula.FormulaResolutionType,NxBRE.InferenceEngine.IO.IBinder,System.String,NxBRE.Util.IDictionaryEvaluator)">
            <summary>
            Instantiates a new Formula predicate.
            </summary>
            <param name="resolutionType">The type of resolution for the formula.</param>
            <param name="bob">The business object binder to use when evaluating the formula, or null.</param>
            <param name="expression">The expression value, i.e. the C# code source that should be computable.</param>
            <param name="evaluator">A precompiled evaluator, or null.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Formula.Clone">
            <summary>
            Returns a clone of the Formula.
            </summary>
            <returns>A clone of the current Formula.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Formula.Evaluate(System.Collections.IDictionary)">
            <summary>
            Evaluate the current Formula with a passed list of arguments.
            </summary>
            <param name="arguments">The name/value pairs of arguments.</param>
            <returns>An object representing the value of the Formula.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Formula.ResolutionType">
            <summary>
            The resolution type used by this formula
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Formula.FormulaResolutionType">
            <summary>
            The different types of resolution methods for the function.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Function">
            <summary>
            An Function is a special predicate that represents an evaluation of a function
            with the tested predicate passed as first argument then the fixed arguments passed
            to the constructor. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Function.#ctor(NxBRE.InferenceEngine.Rules.Function.FunctionResolutionType,System.String,NxBRE.InferenceEngine.IO.IBinder,System.String,System.String[])">
            <summary>
            Instantiates a new function predicate.
            </summary>
            <param name="resolutionType">The type of resolution for the function.</param>
            <param name="predicate">The predicate value, i.e. the string representation of the function predicate.</param>
            <param name="bob">The business object binder to use when evaluating the function, or null.</param>
            <param name="name">The name of the function, as it was analyzed by the binder.</param>
            <param name="arguments">The array of arguments of the function, as it was analyzed by the binder.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Function.Clone">
            <summary>
            Returns a clone of the Function.
            </summary>
            <returns>A clone of the current Individual.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Function.Evaluate(NxBRE.InferenceEngine.Rules.Individual)">
            <summary>
            Checks if an Individual matches the current Function by either calling a NxBRE helper method
            or using a binder.
            </summary>
            <param name="individual">The Individual to check.</param>
            <returns>True if the Individual matches the Function.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Function.ResolutionType">
            <summary>
            The resolution type used by this function
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Function.Binder">
            <summary>
            The binder or null if none is used.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Function.FunctionResolutionType">
            <summary>
            The different types of resolution methods for the function.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.ImplicationAction">
            <summary>
            The possibile implication actions.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.ImplicationPriority">
            <summary>
            The remarkable implication priorities. Any value between in the [0-100] is valid.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Implication">
            <summary>
            An Implication is a specialization of a Query than is able to make deductions.
            </summary>
            <description>
            The Deduction is an Atom that is used as a template that will be filled with values
            provided by facts matching the pattern defined by the atoms of the underlying Query.
            </description>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Query">
            <summary>
            A Query is a collection of non-fact atoms that can be labelled, which can be executed
            against a Fact base in order to produce an ArrayList of facts (a selection of the facts
            matching the data pattern defined by the AtomGroups hierarchy. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Query.#ctor(NxBRE.InferenceEngine.Rules.AtomGroup)">
            <summary>
            Instantiates a new anonymous (non-labelled) Query based on an AtomGroup.
            </summary>
            <param name="atomGroup">The AtomGroup used in the new Query.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Query.#ctor(System.String,NxBRE.InferenceEngine.Rules.AtomGroup)">
            <summary>
            Instantiates a new labelled Query based on an AtomGroup.
            </summary>
            <param name="label">The Label of the new Query.</param>
            <param name="atomGroup">The AtomGroup used in the new Query.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Query.ToString">
            <summary>
            Returns the String representation of the Query for display purpose only.
            </summary>
            <returns>The String representation of the Query.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Query.Equals(System.Object)">
            <summary>
            Checks if the current Query is equal to another one, based on their hashcode.
            </summary>
            <param name="o">The other Query to test the equality.</param>
            <returns>True if the two queries are equal.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Query.GetHashCode">
            <summary>
            Calculates the hashcode of the current Query: if the label is present, it becomes
            the main identifier, else the AtomGroup hashcode is returned.
            </summary>
            <returns>The hashcode of the current Query.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Query.Label">
            <summary>
            The optional Label of the Query.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Query.AtomGroup">
            <summary>
            The top AtomGroup of the Query.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.ToString">
            <summary>
            Returns the String representation of the Implication for display purpose only.
            </summary>
            <returns>The String representation of the Implication.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.GetHashCode">
            <summary>
            Calculates the hashcode of the current Implication by combining the hashcodes of
            its atoms, both in query and deduction.
            If the label is present, it becomes the main identifier of the Implication.
            </summary>
            <returns>The hashcode of the current Query.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.#ctor(System.String,NxBRE.InferenceEngine.Rules.ImplicationPriority,System.String,System.String,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.AtomGroup)">
            <summary>
            Instantiates a new Implication.
            </summary>
            <param name="label">The label of the new implication.</param>
            <param name="priority">The priority  of the new implication.</param>
            <param name="mutex">String.Empty or the label of an implication mutexed by the new one.</param>
            <param name="precondition">String.Empty or the label of an implication that preconditions the new one.</param>
            <param name="deduction">The Atom used as a prototype for what this Implication tries to proove.</param>
            <param name="atomGroup">The top level group of atoms used in the query part (pattern matching) of the new Implication.</param>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationPriority"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.#ctor(System.String,NxBRE.InferenceEngine.Rules.ImplicationPriority,System.String,System.String,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.AtomGroup,NxBRE.InferenceEngine.Rules.ImplicationAction)">
            <summary>
            Instantiates a new Implication.
            </summary>
            <param name="label">The label of the new implication.</param>
            <param name="priority">The priority  of the new implication.</param>
            <param name="mutex">String.Empty or the label of an implication mutexed by the new one.</param>
            <param name="precondition">String.Empty or the label of an implication that preconditions the new one.</param>
            <param name="deduction">The Atom used as a prototype for what this Implication tries to proove.</param>
            <param name="atomGroup">The top level group of atoms used in the query part (pattern matching) of the new Implication.</param>
            <param name="action">The implication action.</param>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationAction"/>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationPriority"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.#ctor(System.String,System.Int32,System.String,System.String,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.AtomGroup)">
            <summary>
            Instantiates a new Implication.
            </summary>
            <param name="label">The label of the new implication.</param>
            <param name="priority">The priority  of the new implication.</param>
            <param name="mutex">String.Empty or the label of an implication mutexed by the new one.</param>
            <param name="precondition">String.Empty or the label of an implication that preconditions the new one.</param>
            <param name="deduction">The Atom used as a prototype for what this Implication tries to proove.</param>
            <param name="atomGroup">The top level group of atoms used in the query part (pattern matching) of the new Implication.</param>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationPriority"/>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Implication.#ctor(System.String,System.Int32,System.String,System.String,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.AtomGroup,NxBRE.InferenceEngine.Rules.ImplicationAction)">
            <summary>
            Instantiates a new Implication.
            </summary>
            <param name="label">The label of the new implication.</param>
            <param name="priority">The priority  of the new implication.</param>
            <param name="mutex">String.Empty or the label of an implication mutexed by the new one.</param>
            <param name="precondition">String.Empty or the label of an implication that preconditions the new one.</param>
            <param name="deduction">The Atom used as a prototype for what this Implication tries to proove.</param>
            <param name="atomGroup">The top level group of atoms used in the query part (pattern matching) of the new Implication.</param>
            <param name="action">The implication action.</param>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationAction"/>
            <see cref="T:NxBRE.InferenceEngine.Rules.ImplicationPriority"/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Deduction">
            <summary>
            The Deduction that this Implication tries to make.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Action">
            <summary>
            Returns the implication action.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Weight">
            <summary>
            The Weight of the Implication is a combination of its Priority and Salience
            and represents its global priority, used in the Agenda.
            </summary>		
            <see cref="T:NxBRE.InferenceEngine.Core.Agenda"/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Priority">
            <summary>
            The Priority of the Implication, as defined in the rule base.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Salience">
            <summary>
            The salience is a computed value the represents the fact that, at equal priority levels,
            the implication that is a pre-condition for another one, must be executed before.
            This behaviour is enabled by assigning a higher salience to the implications that are higher
            in the pre-condition chains.
            </summary>
            <see cref="T:NxBRE.InferenceEngine.Core.PreconditionManager"/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Mutex">
            <summary>
            The optional Label of an Implication that mutexes the current one.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.MutexChain">
            <summary>
            The optional MutexChain the current Implication is member of.
            </summary>		
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.Precondition">
            <summary>
            The optional Label of an Implication whose success preconditions the execution of the current one.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Implication.PreconditionImplication">
            <summary>
            The optional reference to the Implication whose success preconditions the execution of the current one.
            </summary>		
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Individual">
            <summary>
            An Individual is a predicate that represents a fixed value.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Individual.Clone">
            <summary>
            Returns a shallow clone of the Individual, the base value is not cloned.
            </summary>
            <returns>A clone of the current Individual.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Individual.NewArray(System.Object[])">
            <summary>
            A helper method for easily creating an array of Individual predicates.
            </summary>
            <param name="predicates">The array of predicate values.</param>
            <returns>The array of Individual built on the predicate values.</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Slot">
            <summary>
            A Slot is a holder for a named predicate. It is immutable.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Slot.#ctor(System.String,NxBRE.InferenceEngine.Rules.IPredicate)">
            <summary>
            Instantiates a new slot that will hold a named predicate.
            </summary>
            <param name="name">The name of the predicate</param>
            <param name="predicate">The predicate itself</param>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Slot.Value">
            <summary>
            The predicate contained in the slot.
            </summary>
            <remarks>
            Prefer the Predicate property to avoid casting.
            </remarks>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Slot.Name">
            <summary>
            The name of the slot.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.Slot.Predicate">
            <summary>
            The predicate contained in the slot.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.Variable">
            <summary>
            A Variable is a predicate that represents a named value placeholder.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Variable.ToString">
            <summary>
            Converts the value of this Variable to its equivalent string representation,
            for display only. 
            </summary>
            <returns>The string representation of the value of this Variable.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.Variable.Clone">
            <summary>
            Returns a shallow clone of the Variable, the base value is not cloned.
            </summary>
            <returns>A clone of the current Variable</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.AtomFunction">
            <summary>
            An AtomFunction represents a function-driven association of predicates. It is immutable.
            </summary>
            <remarks>This kind of atom does not produce any fact. It validates (or not) a branch
            in the pattern-matching result graph.</remarks>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.#ctor(NxBRE.InferenceEngine.Rules.AtomFunction.RelationResolutionType,System.Boolean,NxBRE.InferenceEngine.IO.IBinder,System.String,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Instantiates a new AtomFunction.
            </summary>
            <param name="resolutionType">The type of resolution for the atom relation function.</param>
            <param name="negative">Negative Atom.</param>
            <param name="bob">The business object binder to use when evaluating the function.</param>
            <param name="type">The relation type of the Atom.</param>
            <param name="members">Array of predicates associated in the Atom.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.#ctor(NxBRE.InferenceEngine.Rules.AtomFunction)">
            <summary>
            Private constructor used for cloning.
            </summary>
            <param name="source">The source AtomFunction to use for building the new one.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.#ctor(NxBRE.InferenceEngine.Rules.AtomFunction,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Private constructor used for cloning.
            </summary>
            <param name="source">The source AtomFunction to use for building the new one.</param>
            <param name="members">The members to use in the new AtomFunction.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.Clone">
            <summary>
            Returns a cloned AtomFunction, of same type and containing a clone of the array of predicates.
            </summary>
            <returns>A new AtomFunction, based on the existing one.</returns>
            <remarks>The predicates are not cloned.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.CloneWithNewMembers(NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Performs a clone of the current AtomFunction but substitute members with the provided ones.
            </summary>
            <param name="members">New members to use.</param>
            <returns>A clone with new members.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomFunction.ToString">
            <summary>
            Returns the String representation of the Atom for display purpose only.
            </summary>
            <returns>The String representation of the Atom.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomFunction.BOB">
            <summary>
            The business object binder to use when evaluating the function.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomFunction.ResolutionType">
            <summary>
            The resolution type for this function.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomFunction.PositiveRelation">
            <summary>
            Returns true if the atom represents a positive relation, i.e. if the evaluation of the
            function, to which the atom's predicates have been passed, has been positive.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.AtomFunction.RelationResolutionType">
            <summary>
            The different types of resolution methods for the atom relation.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.AtomGroup">
            <summary>
            Represents a container that can hold ordered atoms and other groups of atoms related together
            by a logical operator. This defines the hierarchy of atoms in a query or an implication.
            It is immutable.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.GetMemberSortedIndex(System.Object[],System.Int32)">
            <summary>
            Compute an index that allows maitaining original order of members of same kind for sorting them while preserving
            order.
            </summary>
            <param name="runningMembers"></param>
            <param name="originalIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.#ctor(NxBRE.InferenceEngine.Rules.AtomGroup.LogicalOperator,System.Object[])">
            <summary>
            Instantiates a new atom group.
            </summary>
            <param name="logicalOperator">The operator that characterizes the relationship between the atoms and atoms group.</param>
            <param name="members">An array containing atoms and atom groups.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.#ctor(NxBRE.InferenceEngine.Rules.AtomGroup.LogicalOperator,System.Object[],System.Object[])">
            <summary>
            Instantiates a new atom group.
            </summary>
            <param name="logicalOperator">The operator that characterizes the relationship between the atoms and atoms group.</param>
            <param name="members">An array containing atoms and atom groups.</param>
            <param name="runningMembers">An array containing atoms and atom groups that will actually be run (they can be different
            from the members because of atom equivalence).</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.Clone">
            <summary>
            Shallow cloning of the current Atom group.
            </summary>
            <returns>A shallow clone of the current group.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.Equals(System.Object)">
            <summary>
            Determines whether two AtomGroup objects have the same value.
            </summary>
            <param name="o">An Object.</param>
            <returns>true if o is a AtomGroup and its value is the same as this instance;
            otherwise, false.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Rules.AtomGroup.ToString">
            <summary>
            Returns the String representation of the AtomGroup for display purpose only.
            </summary>
            <returns>The String representation of the AtomGroup.</returns>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomGroup.Operator">
            <summary>
            The logical operator used to link the members together
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomGroup.Members">
            <summary>
            The members of the current group, in the original order.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomGroup.AllAtoms">
            <summary>
            The atoms in the current group, and all the subgroups.
            </summary>
        </member>
        <member name="P:NxBRE.InferenceEngine.Rules.AtomGroup.OrderedMembers">
            <summary>
            The atom groups and atoms in the current group with their functions resolved, in the processing order.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Rules.AtomGroup.LogicalOperator">
            <summary>
            Available AtomGroup Logical Operators
            </summary>
        </member>
        <member name="T:NxBRE.Util.Maths">
            <summary>NxBRE Math utilities.</summary>
            <remarks>This class provides basic methods, working only on parameters of same types.
            It is a demonstrator of what is feasable.
            The user is invited to create his/her own maths utilities.
            </remarks>
            <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.Util.Misc">
            <summary>Misc NxBRE utilities.</summary>
            <author>David Dossot</author>
        </member>
        <member name="F:NxBRE.Util.Misc.EMPTY_DICTIONARY">
            <summary>
            An empty read-only IDictionary.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Misc.EMPTY_LIST">
            <summary>
            An empty read-only IList.
            </summary>
        </member>
        <member name="M:NxBRE.Util.Misc.AreIntersecting``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
             Determines if two ArrayList are intersecting, i.e. have an object in common.
            </summary>
             <param name="collectionA">One of the two collections to evaluate.</param>
             <param name="collectionB">The other of the two collections to evaluate.</param>
             <returns>True if at least one object is found in both collections, otherwise false.</returns>
             <remarks>
             For performance reasons, it iterates on the smallest collection and use contains on the other.
             </remarks>
        </member>
        <member name="M:NxBRE.Util.Misc.AreIntersecting(System.Collections.IList,System.Collections.IList)">
            <summary>
             Determines if two ArrayList are intersecting, i.e. have an object in common.
            </summary>
             <param name="collectionA">One of the two collections to evaluate.</param>
             <param name="collectionB">The other of the two collections to evaluate.</param>
             <returns>True if at least one object is found in both collections, otherwise false.</returns>
             <remarks>
             For performance reasons, it iterates on the smallest collection and use contains on the other.
             </remarks>
        </member>
        <member name="M:NxBRE.Util.Misc.ArrayListToString(System.Collections.ArrayList)">
            <summary>
            Outputs the content of an ArrayList in a string.
            </summary>
            <param name="objects">The ArrayList to output.</param>
            <returns>The content of the ArrayList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.ArrayListToString(System.Collections.ArrayList,System.String)">
            <summary>
            Outputs the content of an ArrayList in a string.
            </summary>
            <param name="objects">The ArrayList to output.</param>
            <param name="margin">A left margin string to place before each value.</param>
            <returns>The content of the ArrayList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IListToString(System.Collections.IList)">
            <summary>
            Outputs the content of an IList in a string.
            </summary>
            <param name="objects">The IList to output.</param>
            <returns>The content of the IList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.ArrayToString(System.Array)">
            <summary>
            Outputs the content of an Array in a string.
            </summary>
            <param name="array">The Array to output.</param>
            <returns>The content of the Array in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IListToString``1(System.Collections.Generic.IList{``0})">
            <summary>
            Outputs the content of a generic IList in a string.
            </summary>
            <param name="objects">The IList to output.</param>
            <returns>The content of the IList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IListToString``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Outputs the content of a generic IList in a string.
            </summary>
            <param name="objects">The generic IList to output.</param>
            <param name="margin">A left margin string to place before each value.</param>
            <returns>The content of the IList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IListToString(System.Collections.IList,System.String)">
            <summary>
            Outputs the content of an IList in a string.
            </summary>
            <param name="objects">The IList to output.</param>
            <param name="margin">A left margin string to place before each value.</param>
            <returns>The content of the IList in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IDictionaryToString``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Outputs the content of a generic IDictionary in a string.
            </summary>
            <param name="map">The IDictionary to output.</param>
            <returns>The content of the IDictionary in a string.</returns>
        </member>
        <member name="M:NxBRE.Util.Misc.IDictionaryToString(System.Collections.IDictionary)">
            <summary>
            Outputs the content of an IDictionary in a string.
            </summary>
            <param name="map">The IDictionary to output.</param>
            <returns>The content of the IDictionary in a string.</returns>
        </member>
        <member name="T:NxBRE.Util.Parameter">
            <summary>An helper class for easily accessing NxBRE's application settings and manipulating parameters.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="F:NxBRE.Util.Parameter.COLUMN">
            <summary>
            Char that NxBRE recognizes as a column.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Parameter.PARENTHESIS">
            <summary>
            Chars that NxBRE recognizes as parenthesis.
            </summary>
        </member>
        <member name="M:NxBRE.Util.Parameter.GetEmbeddedResourceStream(System.String)">
            <summary>
            Gets a Stream for a resource embedded in the assembly.
            </summary>
            <param name="resourceName">The name of the resource to get.</param>
            <returns>The Stream that matches the passed resource name, or an exception if it can not be read.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.Get``1(System.String,``0)">
            <summary>Gets the string value of the config file entry.</summary>
             <param name="settingKey">The NxBRE setting key, which is automatically prefixed by "nxbre."</param>
             <param name="defaultValue">The default value to use in case the configuration entry is not found.</param>
             <returns>The config entry string value, unless it is not found then it returns the default value.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.GetEnum(System.String,System.Type,System.Object)">
            <summary>
            Gets the enum value of the config file entry.
            </summary>
            <param name="settingKey">The NxBRE setting key, which is automatically prefixed by "nxbre."</param>
            <param name="enumType">The type of Enum.</param>
            <param name="defaultValue">The default value to use in case the configuration entry is not found.</param>
            <returns>The config entry enum value, unless it is not found then it returns the default value.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.GetString(System.String)">
            <summary>Gets the string value of the config file entry.</summary>
             <param name="settingKey">The NXBRE setting key, which is automatically prefixed by "nxbre."</param>
             <returns>The config entry string value, unless it is not found then it returns null.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.GetTaggedInfo(System.String,System.String)">
            <summary>
             Returns a value from a tagged string.
             The tag is separated from the value by a column (:).
             Each tag:value pair is separated from the other by a semi-column (;).
             The final semi-column is optional.
             Example: if source is GetTaggedInfo("a:1;b:2", "a") returns "1".
             </summary>
             <param name="source">The string containing tagged info.</param>
             <param name="tag">The sought tag, without column (:).</param>
             <returns>The value from the selected tag.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.GroupFinal(System.Object[])">
            <summary>
            Analyzes an array of arguments and group in an array the final ones that would be of same type.
            </summary>
            <remarks>
            This is very useful when calling a method with a final argument being a param array.
            </remarks>
            <param name="arguments">An array of arguments.</param>
            <returns>A new array of arguments, potentially grouped.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.GroupFinal(System.Object[],System.Int32,System.Type)">
            <summary>
            Groups the final objects of an array of arguments in an array, in order to reach
            a certain number of arguments.
            </summary>
            <param name="arguments">An array of arguments.</param>
            <param name="lengthToReach">The desired length for the new array of arguments.</param>
            <param name="targetType">The type of array that will contain the grouped arguments.</param>
            <returns>A new array of arguments, with the final objects grouped in an array.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.BuildFunctionSignature(System.String,System.Object[])">
            <summary>
            Builds a function signature that takes in account the name and the number of arguments.
            </summary>
            <param name="functionName">The name of the function.</param>
            <param name="arguments">An array of arguments.</param>
            <returns>A string that represents the function signature.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.ParseOperatorCall(System.String)">
            <summary>
            Extracts the operator name and its unique argument that must be between parenthesis.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.BuildFormulaSignature(System.String)">
            <summary>
            Builds a formula signature that takes in account the name and the string arguments passed in the parenthesis.
            </summary>
            <param name="formula">The complete formula.</param>
            <returns>A string that represents the function signature.</returns>
        </member>
        <member name="M:NxBRE.Util.Parameter.TrimPrefix(System.String)">
            <summary>
            Trims the prefix that could prepend a formula (like "expr:" in "expr:XYZ")
            </summary>
            <param name="formulaName">The formula name, which could be prefixed</param>
            <returns>The unprefixed formula name</returns>
        </member>
        <member name="T:NxBRE.Util.FormulaSignature">
            <summary>
            A internal immutable class used as a return value for method BuildFormulaSignature.
            </summary>
        </member>
        <member name="T:NxBRE.Util.ObjectPair">
            <summary>
            A class designed for olding pairs of objects
            </summary>
        </member>
        <member name="M:NxBRE.Util.ObjectPair.#ctor">
            <summary>
            Instantiates a new pair object with no reference (null) to any object.
            </summary>
        </member>
        <member name="M:NxBRE.Util.ObjectPair.#ctor(System.Object,System.Object)">
            <summary>
            Instantiates a new pair object with references to the provided objects.
            </summary>
            <param name="first">Reference of the first object in the pair.</param>
            <param name="second">Reference of the second object in the pair.</param>
        </member>
        <member name="P:NxBRE.Util.ObjectPair.First">
            <summary>
            Gets or sets the reference of the first object in the pair.
            </summary>
        </member>
        <member name="P:NxBRE.Util.ObjectPair.Second">
            <summary>
            Gets or sets the reference of the second object in the pair.
            </summary>
        </member>
        <member name="T:NxBRE.Util.HyperLink">
            <summary>
            An immutable class designed for storing an hyperlink
            </summary>
        </member>
        <member name="T:NxBRE.Util.PseudoCodeRenderer">
            <summary>An helper class for rendering XBusinessRules in pseudo-code HTML.
            The class can render the rules body, an index on these rules and a frameset
            to encapsulate them both.
            </summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.#ctor(System.String)">
            <summary>Instantiate a new renderer for a specific rule file.</summary>
             <param name="ruleFileURI">The URI of a rule file that validates on xBusinessRules.xsd</param>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderBody(System.String,System.String)">
            <summary>Renders the body of the rule file in pseudo-code HTML.</summary>
            <param name="fileName">Output file name to generate.</param>
            <param name="title">Title for the HTML page.
            If null, the default value defined in pseudocode_body.xsl will be used.</param>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderBody(System.IO.Stream,System.String)">
            <summary>Renders the body of the rule file in pseudo-code HTML.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <param name="title">Title for the HTML page.
            If null, the default value defined in pseudocode_body.xsl will be used.</param>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderBody(System.String)">
            <summary>Renders the body of the rule file in pseudo-code HTML.</summary>
            <param name="fileName">Output file name to generate.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderBody(System.IO.Stream)">
            <summary>Renders the body of the rule file in pseudo-code HTML.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderIndex(System.String,System.String,System.String)">
            <summary>Renders the index of the rule file in pseudo-code HTML.</summary>
            <param name="fileName">Output file name to generate.</param>
            <param name="title">Title for the HTML page.</param>
            <param name="bodyURI">URI where the pseudo-code rules body is stored.
            It will be used for generating a correct "a href" HTML tag.
            </param>
            <description>If title or bodyURI are null, the default value defined in pseudocode_index.xsl will be used.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderIndex(System.IO.Stream,System.String,System.String)">
            <summary>Renders the index of the rule file in pseudo-code HTML.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <param name="title">Title for the HTML page.</param>
            <param name="bodyURI">URI where the pseudo-code rules body is stored.
            It will be used for generating a correct "a href" HTML tag.
            </param>
            <description>If title or bodyURI are null, the default value defined in pseudocode_index.xsl will be used.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderIndex(System.String)">
            <summary>Renders the index of the rule file in pseudo-code HTML.</summary>
            <param name="fileName">Output file name to generate.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderIndex(System.IO.Stream)">
            <summary>Renders the index of the rule file in pseudo-code HTML.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderFrameset(System.String,System.String,System.String,System.String)">
            <summary>Renders a frameset for encapsulating pseudo-code HTML rule body and index.</summary>
            <param name="fileName">Output file name to generate.</param>
            <param name="title">Title for the HTML page.</param>
            <param name="indexURI">URI where the pseudo-code rules index is stored.</param>
            <param name="bodyURI">URI where the pseudo-code rules body is stored.</param>
            <description>If title, indexURI or bodyURI are null, the default value defined in pseudocode_frames.xsl will be used.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderFrameset(System.IO.Stream,System.String,System.String,System.String)">
            <summary>Renders a frameset for encapsulating pseudo-code HTML rule body and index.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <param name="title">Title for the HTML page.</param>
            <param name="indexURI">URI where the pseudo-code rules index is stored.</param>
            <param name="bodyURI">URI where the pseudo-code rules body is stored.</param>
            <description>If title, indexURI or bodyURI are null, the default value defined in pseudocode_frames.xsl will be used.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderFrameset(System.String)">
            <summary>Renders a frameset for encapsulating pseudo-code HTML rule body and index.</summary>
            <param name="fileName">Output file name to generate.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="M:NxBRE.Util.PseudoCodeRenderer.RenderFrameset(System.IO.Stream)">
            <summary>Renders a frameset for encapsulating pseudo-code HTML rule body and index.</summary>
            <param name="stream">Stream into which the generated page will be writen to.</param>
            <description>Default values are used in this shorter method call.</description>
        </member>
        <member name="T:NxBRE.Util.Reflection">
            <summary>NxBRE utilities for manipulations on objects: reflection, type casting...</summary>
            <author>David Dossot</author>
        </member>
        <member name="F:NxBRE.Util.Reflection.CULTURE_INFO">
            <summary>
            When casting values, NxBRE uses this format: en-US.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Reflection.NXBRE_VERSION">
            <summary>
            Version of the current NxBRE engine.
            </summary>
        </member>
        <member name="M:NxBRE.Util.Reflection.IsNull(System.Object)">
            <summary>
            Tests if an object is null.
            </summary>
            <param name="o">The object to test.</param>
            <returns>True if null was passed as argument.</returns>
        </member>
        <member name="M:NxBRE.Util.Reflection.CastValue(System.Object,System.String)">
            <summary>
            Casts a certain valueObject into a certain type, by using ChangeType when possible
            (i.e. except for exceptions).
            </summary>
            <param name="valueObject">The object to cast</param>
            <param name="typeName">The full name of the type to cast to</param>
            <returns>A properly casted object, unless an exception occurs.</returns>
        </member>
        <member name="M:NxBRE.Util.Reflection.CastValue(System.Object,System.Type)">
            <summary>
            Casts a certain valueObject into a certain type, by using ChangeType when possible
            (i.e. except for exceptions).
            </summary>
            <param name="valueObject">The object to cast</param>
            <param name="type">The type to cast to</param>
            <returns>A properly casted object, unless an exception occurs.</returns>
        </member>
        <member name="M:NxBRE.Util.Reflection.CastToStrongType(NxBRE.Util.ObjectPair)">
            <summary>
            Converts either object1 to the type of object2, or the contrary, based on the object having
            the weakest type, i.e. System.String. If none of the objects are System.String
            object2 will be casted to object1.
            </summary>
            <param name="pair">A reference to the pair of objects to cast.</param>
        </member>
        <member name="M:NxBRE.Util.Reflection.ObjectCall(System.Object,System.String,System.Object[])">
            <summary>
            Calls a member on an object, either to get or set an attribute or property,
            or to invoke a method.
            </summary>
            <param name="target">The object on which the member will be called.</param>
            <param name="name">The name of the member to call.</param>
            <param name="argValues">An array of arguments. Use null if no argument is needed.</param>
            <returns>The value returned when the member is a method, else null.</returns>
        </member>
        <member name="M:NxBRE.Util.Reflection.ClassCall(System.String,System.String,System.Object[])">
            <summary>
            Calls a static member on a class, either to get or set an attribute or property,
            or to invoke a method.
            </summary>
            <param name="type">The fully qualified name of the class to call.</param>
            <param name="name">The name of the member to call.</param>
            <param name="argValues">An array of arguments. Use null if no argument is needed.</param>
            <returns>The value returned when the member is a method, else null.</returns>
        </member>
        <member name="M:NxBRE.Util.Reflection.ClassNew(System.String,System.Object[])">
            <summary>
            Instantiates a new object.
            </summary>
            <param name="type">The fully qualified name of the class to instantiate.</param>
            <param name="argValues">An array of contructor arguments. Use null if no argument is needed.</param>
            <returns></returns>
        </member>
        <member name="P:NxBRE.Util.Reflection.NxBREAssembly">
            <summary>
            Returns the NxBRE assembly.
            </summary>
            <remarks>
            Created as a replacement for Assembly.GetExecutingAssembly() per bug report 1709279
            </remarks>
        </member>
        <member name="T:NxBRE.Util.Xml">
            <summary>Schema utilities.</summary>
            <author>David Dossot</author>
        </member>
        <member name="F:NxBRE.Util.Xml.NS_URI">
            <summary>
            Namespace of XML Schema Instance v1.4.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Xml.compiledTransformCache">
            <summary>
            Cache of compiled XSL templates.
            </summary>
            <remarks>Inspired by patch 1516398 submitted by Koen Muilwijk</remarks>
        </member>
        <member name="M:NxBRE.Util.Xml.GetCachedCompiledTransform(System.String)">
            <summary>
            Access the internal cache of XslCompiledTransform object built from embedded resources.
            </summary>
            <param name="xslResourceName">Embedded Xsl resource name</param>
            <returns>The XslCompiledTransform built from this resource</returns>
        </member>
        <member name="M:NxBRE.Util.Xml.NewValidatingReader(System.Xml.XmlReader)">
            <summary>
            Instantiates a new validating XML reader, with validation type being None.
            </summary>
            <param name="xmlReader"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.NewValidatingReader(System.Xml.XmlReader,System.Xml.ValidationType)">
            <summary>
            Instantiates a new validating XML reader.
            </summary>
            <param name="xmlReader"></param>
            <param name="validationType"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.NewValidatingReader(System.Xml.XmlReader,System.Xml.ValidationType,System.String[])">
            <summary>
            Instantiates a new validating XML reader.
            </summary>
            <param name="xmlReader"></param>
            <param name="validationType"></param>
            <param name="xsdResourceName"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.GetSchemaTypeFromClr(System.Object)">
            <summary>
            Gets the best matching Xml schema type for an object.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.FromClr(System.Object)">
            <summary>
            Gets an XML string out of an object, using the most appropriate XML schema type.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.FromClr(System.Object,System.String)">
            <summary>
            Gets an XML string out of an object following a specific XML schema type.
            </summary>
            <param name="value"></param>
            <param name="schemaType"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.Util.Xml.ToClr(System.String,System.String)">
            <summary>
            Gets an object instance out of an XML string and an XML schema type.
            </summary>
            <param name="value"></param>
            <param name="schemaType"></param>
            <returns></returns>
        </member>
        <member name="P:NxBRE.Util.Xml.IdentityXSLT">
            <summary>
            Ready made identity XSLT, usefull for XML persistence
            </summary>
            <returns>An XslTransform ready to performe an identity transform</returns>
        </member>
        <member name="T:NxBRE.Util.IDictionaryEvaluator">
            <summary>
            An evaluator that receives its arguments as key/value pairs.
            </summary>
        </member>
        <member name="T:NxBRE.Util.IListEvaluator">
            <summary>
            An evaluator that receives its arguments as a list of values, whose position is important.
            </summary>
        </member>
        <member name="T:NxBRE.Util.IEvaluator">
            <summary>
            An evaluator that takes no arguments.
            </summary>
        </member>
        <member name="T:NxBRE.Util.Compilation">
            <summary>NxBRE utilities for on-the-fly compiling C# code</summary>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.Util.Compilation.Evaluate(System.String)">
            <summary>
            Performs an immediate evaluation of an expression that takes no argument.
            </summary>
            <remarks>
            The compiled expression is not cached.
            </remarks>
            <param name="expression">The C# expression to evaluate.</param>
            <returns>An object produced by the expression.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.Evaluate(System.String,System.String,System.Collections.IList,System.Collections.IList)">
            <summary>
            Performs an immediate evaluation of an expression that takes lists for parameter names and values.
            </summary>
            <remarks>
            The compiled expression is not cached.
            </remarks>
            <param name="expression">The C# expression to evaluate.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="variableNames">The list of argument names.</param>
            <param name="values">The list of values.</param>
            <returns>An object produced by the expression.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.NewEvaluator(System.String,System.String,System.Collections.IList,System.Collections.IList)">
            <summary>
            Instantiates a new evaluator that receives its arguments as a list of values.
            </summary>
            <param name="expression">The C# expression to compile.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="variableNames">The list of argument names.</param>
            <param name="values">The list of values.</param>
            <returns>The compiled evaluator.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.Evaluate(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Performs an immediate evaluation of an expression that takes key/value pairs as arguments.
            </summary>
            <remarks>
            The compiled expression is not cached.
            </remarks>
            <param name="expression">The C# expression to evaluate.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="arguments">The key/value pairs of arguments.</param>
            <returns>An object produced by the expression.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.Evaluate(System.String,System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Performs an immediate evaluation of an expression that takes key/value pairs as arguments.
            </summary>
            <remarks>
            The compiled expression is not cached.
            </remarks>
            <param name="expression">The C# expression to evaluate.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="numericArgumentPattern">A regexp pattern used to recognize placeholders for arguments whose names are integers and not strings. Use null if not needed.</param>
            <param name="arguments">The key/value pairs of arguments.</param>
            <returns>An object produced by the expression.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.NewEvaluator(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Instantiates a new evaluator that receives its arguments as key/value pairs.
            </summary>
            <param name="expression">The C# expression to evaluate.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="arguments">The key/value pairs of arguments.</param>
            <returns>The compiled evaluator.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.NewEvaluator(System.String,System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Instantiates a new evaluator that receives its arguments as key/value pairs.
            </summary>
            <param name="expression">The C# expression to evaluate.</param>
            <param name="placeHolderRegexpPattern">The regexp used to recoginize the argument placeholders.</param>
            <param name="numericArgumentPattern">A regexp pattern used to recognize placeholders for arguments whose names are integers and not strings. Use null if not needed.</param>
            <param name="arguments">The key/value pairs of arguments.</param>
            <returns>The compiled evaluator.</returns>
        </member>
        <member name="M:NxBRE.Util.Compilation.LoadClass(System.CodeDom.Compiler.CodeDomProvider,System.String,System.String,System.Boolean)">
            <remarks>Brendan Ingram has greatly improved this method.</remarks>		
        </member>
        <member name="P:NxBRE.Util.Compilation.ReferenceLinkMode">
            <summary>
            Gets or sets the active reference link mode. Default is Full.
            </summary>
        </member>
        <member name="P:NxBRE.Util.Compilation.GenerateInMemoryAssembly">
            <summary>
            Gets or sets the active mode for dynamic assembly compilation. Default is in-memory.
            <see cref="P:System.CodeDom.Compiler.CompilerParameters.GenerateInMemory"/>
            </summary>
            <remarks>
            Patch 1740387 submitted by Marcin Kielar (zorba128)
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Compilation.CompilerOptions">
            <summary>
            Gets or sets the optional additional-command line arguments string to use when invoking the compiler.
            </summary>
            <see cref="P:System.CodeDom.Compiler.CompilerParameters.CompilerOptions"/>
        </member>
        <member name="T:NxBRE.Util.Compilation.ReferenceLinkModes">
            <summary>
            Defines the different strategies for adding references when on-the-fly compiling classes.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Compilation.ReferenceLinkModes.None">
            <summary>
            No references will be added.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Compilation.ReferenceLinkModes.NxBRE">
            <summary>
            Only a reference to NxBRE.dll will be added.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Compilation.ReferenceLinkModes.CurrentDomain">
            <summary>
            References to all assemblies of the current domain will be added.
            </summary>
        </member>
        <member name="F:NxBRE.Util.Compilation.ReferenceLinkModes.Full">
            <summary>
            References to NxBRE.dll and all assemblies of the current domain will be added.
            </summary>
        </member>
        <member name="T:NxBRE.Util.DataAccess">
            <summary>NxBRE Data utilities.</summary>
            <remarks>This class provides very basic methods, it is a demonstrator of what is feasable.
            The user is invited to create his/her own data access utilities.
            </remarks>
            <author>David Dossot</author>
        </member>
        <member name="M:NxBRE.Util.DataAccess.GetDataRowColumnValue(System.Data.DataRow,System.String)">
            <summary>
            Get a value from a DataRow column.
            </summary>
            <param name="dr">The DataRow to read from.</param>
            <param name="columnName">The name of the column to read.</param>
            <returns>The read object.</returns>
            <see cref="T:System.Data.DataRow"/>
        </member>
        <member name="M:NxBRE.Util.DataAccess.SetDataRowColumnValue(System.Data.DataRow,System.String,System.Object)">
            <summary>
            Set a value in DataRow column.
            </summary>
            <param name="dr">The DataRow to modify.</param>
            <param name="columnName">The name of the column to set.</param>
            <param name="columnValue">The new value for the column.</param>
            <see cref="T:System.Data.DataRow"/>
        </member>
        <member name="M:NxBRE.Util.DataAccess.GetArrayColumnValue(System.Object[],System.Int32)">
            <summary>
            Get a value from a Array column.
            </summary>
            <param name="array">The Array to read from.</param>
            <param name="columnIndex">The name of the column to read.</param>
            <returns>The read object.</returns>
        </member>
        <member name="M:NxBRE.Util.DataAccess.SetArrayColumnValue(System.Object[],System.Int32,System.Object)">
            <summary>
            Set a value in Array column.
            </summary>
            <param name="array">The Array to modify.</param>
            <param name="columnIndex">The name of the column to set.</param>
            <param name="columnValue">The new value for the column.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.GetAll(System.Collections.Generic.IList{NxBRE.InferenceEngine.Rules.Equivalent},NxBRE.InferenceEngine.Rules.Atom,System.Collections.ArrayList)">
            <summary>
            Internal method used for exploring the potential hierarchy of equivalence and building the complete
            list of atoms equivalent to one atom.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.ResolveFunctions(NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Resolves all Function predicates by replacing them by their String representations.
            </summary>
            <param name="atom">The Atom to resolve.</param>
            <returns>A new Atom where all Function predicates have been resolved. If no
            Function predicate exists, it returns a clone of the current Atom.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.TranslateVariables(NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Translates variable names of a target atom with names from a template atom matching the position of a
            source atom.
            </summary>
            <remarks>Template and source atoms must match together else unpredictible result may occur.</remarks>
            <param name="template"></param>
            <param name="source"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.Populate(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Atom,NxBRE.InferenceEngine.Rules.IPredicate[])">
            <summary>
            Populates the Variable predicates of a target Atom, using another Atom as a template
            and a Fact as the source of data, i.e. Individual predicates.
            </summary>
            <param name="data">The data for populating the Atom.</param>
            <param name="template">The template of Atom being populated.</param>
            <param name="members">The members to populate.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.Resolve(NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Prepare the atom to be pattern matched by replacing in a fact:
            -  all the predicates that match function predicates in the passed atom with 
              the string representation of these function predicates,
            -  all the predicates that match individual predicates in the passed atom with 
              the string representation of these individual predicates.
            </summary>
            <remarks>
            This operation must be done *if and only if* the fact matches the atom.
            </remarks>
            <param name="factToResolve">The fact that must be resolved.</param>
            <param name="atom">The atom with which the current fact matches.</param>
            <returns>A new fact with only String individuals.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Core.RulesUtil.Resolve(System.Boolean,NxBRE.InferenceEngine.Rules.Fact,NxBRE.InferenceEngine.Rules.Atom)">
            <summary>
            Prepare the atom to be pattern matched by replacing in a fact:
            -  all the predicates that match function predicates in the passed atom with 
              the string representation of these function predicates,
            -  in fully mode, all the predicates that match individual predicates in the passed atom with 
              the string representation of these individual predicates.
            </summary>
            <remarks>
            This operation must be done *if and only if* the fact matches the atom.
            </remarks>
            <param name="fully">Forces resolution of non-string individual to String.</param>
            <param name="factToResolve">The fact that must be resolved.</param>
            <param name="atom">The atom with which the current fact matches.</param>
            <returns>A new fact with only String individuals.</returns>
        </member>
        <member name="F:NxBRE.Util.Logger.traceEventTypeValues">
            <summary>
            A preloaded array of possible TraceEventTypes
            </summary>
        </member>
        <member name="M:NxBRE.Util.Logger.RefreshBooleanSwitches">
            <summary>
            Set the different switches used by NxBRE to the levels defined in the different souces
            (usually set up in the configuration file).
            </summary>
            <remarks>
            This method must be called any time an NxBRE TraceSource Switch Level has been programmatically modified.
            </remarks>
        </member>
        <member name="M:NxBRE.Util.Logger.ConvertFromObsoleteIntLevel(System.Int32)">
            <summary>
            Converts old and obsolete int based trace levels from NxBRE v2 to .NET 2.0 trace event types
            </summary>
            <param name="traceLevel">The integer representing the trace level in the old system.</param>
            <returns>The matching TraceEventType or TraceEventType.Information if no match found.</returns>
        </member>
        <member name="P:NxBRE.Util.Logger.FlowEngineSource">
            <summary>
            The Trace Source used by NxBRE.FlowEngine
            </summary>
        </member>
        <member name="P:NxBRE.Util.Logger.FlowEngineRuleBaseSource">
            <summary>
            The Trace Source used by NxBRE.FlowEngine.RuleBase generated traces
            </summary>
        </member>
        <member name="P:NxBRE.Util.Logger.InferenceEngineSource">
            <summary>
            The Trace Source used by NxBRE.InferenceEngine
            </summary>
        </member>
        <member name="P:NxBRE.Util.Logger.UtilSource">
            <summary>
            The Trace Source used by NxBRE.Util
            </summary>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineVerbose">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineInformation">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineWarning">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineError">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineCritical">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineRuleBaseError">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsFlowEngineRuleBaseCritical">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsInferenceEngineVerbose">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsInferenceEngineInformation">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsInferenceEngineWarning">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsUtilVerbose">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsUtilInformation">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="P:NxBRE.Util.Logger.IsUtilWarning">
            <summary>
            A trace switch used by NxBRE. It can be changed at runtime by the user.
            </summary>
            <remarks>
            To revert to the value defined in the configuration file, call RefreshBooleanSwitches (<see cref="M:NxBRE.Util.Logger.RefreshBooleanSwitches"/>).
            </remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.FileRegistry">
            <summary>
            A registry of preloaded NxBRE Inference Engines instances. The registry is configured by a specific definition file and
            RuleML and binder files, all stored in the same folder.
            
            Each engine is identified in the registry by a String ID.
            
            If any of the file that was used to load the engine (rule file or binder) is modified, the registry automatically reloads
            it, without disrupting the users of the engines.
            </summary>
            <remarks>
            The registry does not reload itself if its configuration file is changed.
            </remarks>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.IRegistry">
            <summary>
            Defines a registry of preloaded NxBRE Inference Engines instances where each engine is identified in the registry by a String ID.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.FileRegistry.registry">
            <summary>
            Dictionary that stores all the engines, made immutable to prevent any modifications outside of the constructor.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.FileRegistry.fileIndex">
            <summary>
            Dictionary that stores all the rule and binder files names that are involved in the registry and the ID
            of the engine they are related to. This is a kind of "reverse phone book" that allows finding the engine
            that depends on a certain file.
            </summary>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.FileRegistry.configuration">
            <summary>
            The configuration used for the current file registry instance.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.GetEngine(System.String)">
            <summary>
            Get a named instance of an inference engine out of the registry.
            </summary>
            <param name="engineID">The ID of the engine to get</param>
            <returns>The desired engine instance or null if it is not available in the registry</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.#ctor(System.String)">
            <summary>
            Initializes a new registry of NxBRE Inference Engines.
            </summary>
            <param name="registryConfigurationFile">The full path and file name of the registry configuration file.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.OnRegistryFileEvent(System.String,System.String)">
            <summary>
            Handles all file events that are intercepted on the file system.
            </summary>
            <param name="fullFileName">The complete name of the file that has been somehow altered.</param>
            <param name="fileName">The name of the registry file that has been somehow altered.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.WaitUntilFileCanBeRead(System.String)">
            <summary>
            Ponders for ever until the file referenced in the registry is available for reading.
            </summary>
            <param name="fullFileName">The full path to the file.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.OnFileChanged(System.Object,System.IO.FileSystemEventArgs)">
            <summary>
            Handles file system events fired when a file is changed.
            </summary>
            <param name="source">The source of the event. </param>
            <param name="e">The FileSystemEventArgs that contains the event data.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.Registry.FileRegistry.OnFileRenamed(System.Object,System.IO.RenamedEventArgs)">
            <summary>
            Handles file system events fired when a file is renamed.
            </summary>
            <param name="source">The source of the event. </param>
            <param name="e">The RenamedEventArgs that contains the event data.</param>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.FileRegistry.CachedEngine">
            <summary>
            The class used to hold an engine details and performs its (re)loading.
            </summary>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.FileRegistryConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.FileRegistryConfiguration.Engines">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.FileRegistryConfiguration.Folder">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.FileRegistryConfiguration.FileLockedPonderatingTime">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.EngineConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.EngineConfiguration.Rules">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.EngineConfiguration.Binder">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.EngineConfiguration.Id">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.RulesConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.RulesConfiguration.File">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.RulesConfiguration.Format">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.RulesFormat">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.HRF086">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.RuleML08Datalog">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.RuleML086Datalog">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.RuleML086NafDatalog">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.RuleML09NafDatalog">
            <remarks/>
        </member>
        <member name="F:NxBRE.InferenceEngine.Registry.RulesFormat.Visio2003">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.CSharpBinderConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.CSharpBinderConfiguration.File">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.CSharpBinderConfiguration.Class">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.VisualBasicBinderConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.VisualBasicBinderConfiguration.File">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.VisualBasicBinderConfiguration.Class">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.Registry.FlowEngineBinderConfiguration">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.FlowEngineBinderConfiguration.File">
            <remarks/>
        </member>
        <member name="P:NxBRE.InferenceEngine.Registry.FlowEngineBinderConfiguration.Type">
            <remarks/>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.VisualBasicBinderFactory">
            <summary>
            This class is a helper for instantiating IBinder objects from VB.NET files,
            giving the performance of a binder embedded in the main application and the
            flexibility of a file-based external binder.
            </summary>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.VisualBasicBinderFactory.LoadFromFile(System.String,System.String)">
            <summary>
            Instantiates a new IBinder class.
            </summary>
            <param name="binderClassName">The fully qualified class name of the binder class.</param>
            <param name="binderClassFileName">The full path of the file containing the VB.NET source code of the class.</param>
            <returns>A new instance of IBinder based on the class definition.</returns>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.VisualBasicBinderFactory.LoadFromString(System.String,System.String)">
            <summary>
            Instantiates a new IBinder class.
            </summary>
            <param name="binderClassName">The fully qualified class name of the binder class.</param>
            <param name="binderClassSource">The VB.NET source code of the class.</param>
            <returns>A new instance of IBinder based on the class definition.</returns>
        </member>
        <member name="T:NxBRE.Util.HashCodeBuilder">
            <summary>
            A helper object for building hashcode based certain objects that belongs to a particular class.
            </summary>
            <remarks>
            This helper follows Joshua Bloch's Effective Java recommandations on computing hashcode.
            </remarks>
        </member>
        <member name="M:NxBRE.Util.HashCodeBuilder.#ctor">
            <summary>
            Creates a new HashCodeBuilder initialized for computing a new hashcode.
            </summary>
        </member>
        <member name="M:NxBRE.Util.HashCodeBuilder.#ctor(System.Int32)">
            <summary>
            Creates a new HashCodeBuilder initialized for extending an existing hashcode.
            </summary>
            <param name="hashCode">An actual existing hashcode.</param>
            <remarks>Do not call this method with a random number, if you do not have an existing hashcode use the empty constructor.</remarks>
        </member>
        <member name="M:NxBRE.Util.HashCodeBuilder.Append(System.Object)">
            <summary>
            Append a new object (usually an object's field) to the current hashcode.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="P:NxBRE.Util.HashCodeBuilder.Value">
            <summary>
            The current hashcode value computed by this instance of HashCodeBuilder.
            </summary>
        </member>
        <member name="T:NxBRE.Util.HashSet`1">
            <summary>
            A HashSet is collection that contains only unique items and uses their hash code to determine their unicity.
            </summary>
        </member>
        <member name="T:NxBRE.FlowEngine.Rules.Matches">
            <summary> Compares one object to a regexp to see if they match.
            </summary>
            <author>  David Dossot
            </author>
        </member>
        <member name="M:NxBRE.FlowEngine.Rules.Matches.ExecuteComparison(NxBRE.FlowEngine.IBRERuleContext,System.Collections.IDictionary,System.Object,System.Object)">
            <summary> Check if object matches a regexp pattern
            </summary>
            <param name="aBRC">The BRERuleContext object containing all the state
            information for use by this method.
            </param>
            <param name="aMap">Not used yet. An IDictionary object containing the parameters from the XML
            </param>
            <param name="compareTo">The object to compare it to.
            </param>
            <param name="regexPattern">The regexp pattern to match against.
            </param>
            <returns> True if they meet the condition, False otherwise.
            </returns>
        </member>
        <member name="P:NxBRE.FlowEngine.Rules.Matches.AcceptsNulls">
            <summary>Defines whether an operator is able to deal with empty operands</summary>
            <returns>True for the current operator</returns>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.RuleML091NafDatalogAdapter">
            <summary>Adapter supporting RuleML 0.91 NafDatalog Sublanguage.</summary>
            <remarks>UTF-8 is the default encoding.</remarks>
             <author>David Dossot</author>
        </member>
        <member name="T:NxBRE.InferenceEngine.IO.AccumulatingExtendedRuleBaseAdapter">
            <summary>
            An abstract rule base adapter that accumulate all collections and restitutes them in one method
            at dispose time.
            </summary>
            <remarks>
            Currently extends RuleML09NafDatalogAdapter but will probably be higher in the class hierarchy later.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AccumulatingExtendedRuleBaseAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Only delegates to base constructor.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AccumulatingExtendedRuleBaseAdapter.#ctor(System.IO.Stream,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Only delegates to base constructor.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AccumulatingExtendedRuleBaseAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Only delegates to base constructor.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.AccumulatingExtendedRuleBaseAdapter.#ctor(System.String,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Only delegates to base constructor.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML091NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.91 NafDatalog adapter for reading from or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <remarks>
            By default, the standard syntax is used and non-typed individuals are not typified.
            When reading, all formats are automatically supported.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML091NafDatalogAdapter.#ctor(System.IO.Stream,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Instantiates a RuleML 0.91 NafDatalog adapter for reading from or writing to a stream.
            </summary>
            <param name="streamRuleML">The stream to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
            <remarks>When reading, all formats are automatically supported.</remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML091NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess)">
            <summary>
            Instantiates a RuleML 0.91 NafDatalog adapter for reading from or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <remarks>
            By default, the standard syntax is used and non-typed individuals are not typified.
            When reading, all formats are automatically supported.
            </remarks>
        </member>
        <member name="M:NxBRE.InferenceEngine.IO.RuleML091NafDatalogAdapter.#ctor(System.String,System.IO.FileAccess,NxBRE.InferenceEngine.IO.SaveFormatAttributes)">
            <summary>
            Instantiates a RuleML 0.91 Datalog adapter for reading from or writing to an URI.
            </summary>
            <param name="uriRuleML">The URI to read from or write to.</param>
            <param name="mode">The FileAccess mode.</param>
            <param name="attributes">The RuleML format attributes, only used if writing.</param>
            <remarks>When reading, all formats are automatically supported.</remarks>
        </member>
    </members>
</doc>
